{"description":"There are n persons who initially don't know each other. On each morning, two of them, who were not friends before, become friends.\nWe want to plan a trip for every evening of m days. On each trip, you have to select a group of people that will go on the trip. For every person, one of the following should hold: \n  * Either this person does not go on the trip, \n  * Or at least k of his friends also go on the trip. \nNote that the friendship is not transitive. That is, if a and b are friends and b and c are friends, it does not necessarily imply that a and c are friends.\nFor each day, find the maximum number of people that can go on the trip on that day.\nInput\nThe first line contains three integers n, m, and k (2 \u2264 n \u2264 2 \u22c5 10^5, 1 \u2264 m \u2264 2 \u22c5 10^5, 1 \u2264 k < n) \u2014 the number of people, the number of days and the number of friends each person on the trip should have in the group.\nThe i-th (1 \u2264 i \u2264 m) of the next m lines contains two integers x and y (1\u2264 x, y\u2264 n, x\u2260 y), meaning that persons x and y become friends on the morning of day i. It is guaranteed that x and y were not friends before.\nOutput\nPrint exactly m lines, where the i-th of them (1\u2264 i\u2264 m) contains the maximum number of people that can go on the trip on the evening of the day i.\nExamples\nInput\n4 4 2\n2 3\n1 2\n1 3\n1 4\nOutput\n0\n0\n3\n3\nInput\n5 8 2\n2 1\n4 2\n5 4\n5 2\n4 3\n5 1\n4 1\n3 2\nOutput\n0\n0\n0\n3\n3\n4\n4\n5\nInput\n5 7 2\n1 5\n3 2\n2 5\n3 4\n1 2\n5 3\n1 3\nOutput\n0\n0\n0\n0\n3\n4\n4\nNote\nIn the first example, \n  * 1,2,3 can go on day 3 and 4. \nIn the second example, \n  * 2,4,5 can go on day 4 and 5. \n  * 1,2,4,5 can go on day 6 and 7. \n  * 1,2,3,4,5 can go on day 8. \nIn the third example, \n  * 1,2,5 can go on day 5. \n  * 1,2,3,5 can go on day 6 and 7. ","sample_inputs":"4 4 2\n2 3\n1 2\n1 3\n1 4\n5 8 2\n2 1\n4 2\n5 4\n5 2\n4 3\n5 1\n4 1\n3 2\n5 7 2\n1 5\n3 2\n2 5\n3 4\n1 2\n5 3\n1 3\n","sample_outputs":"0\n0\n3\n3\n0\n0\n0\n3\n3\n4\n4\n5\n0\n0\n0\n0\n3\n4\n4\n","cf_tags":["graphs"],"original_code":"from collections import deque\n\ndef solve(adj, m, k, uv):\n    n = len(adj)\n    nn = [len(a) for a in adj]\n    q = deque()\n    for i in range(n):\n        if nn[i] < k:\n            q.append(i)\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            nn[u] -= 1\n            if nn[u] == k-1:\n                q.append(u)\n    res = [0]*m\n    nk = len([1 for i in nn if i >= k])\n    res[-1] = nk\n    for i in range(m-1, 0, -1):\n        u1, v1 = uv[i]\n\n        if nn[u1] < k or nn[v1] < k:\n            res[i - 1] = nk\n            continue\n        if nn[u1] == k:\n            q.append(u1)\n            nn[u1] -= 1\n        if not q and nn[v1] == k:\n            q.append(v1)\n            nn[v1] -= 1\n\n        if not q:\n            nn[u1] -= 1\n            nn[v1] -= 1\n            adj[u1].remove(v1)\n            adj[v1].remove(u1)\n\n        while q:\n            v = q.popleft()\n            nk -= 1\n            for u in adj[v]:\n                nn[u] -= 1\n                if nn[u] == k - 1:\n                    q.append(u)\n        res[i - 1] = nk\n    return res\n\nn, m, k = map(int, input().split())\na = [set() for i in range(n)]\nuv = []\nfor i in range(m):\n    u, v = map(int, input().split())\n    a[u - 1].add(v - 1)\n    a[v - 1].add(u - 1)\n    uv.append((u-1, v-1))\n\nres = solve(a, m, k, uv)\nprint(str(res)[1:-1].replace(' ', '').replace(',', '\\n'))","cleaned_code":"from collections import deque\ndef solve(adj, m, k, uv):\n    n = len(adj)\n    nn = [len(a) for a in adj]\n    q = deque()\n    for i in range(n):\n        if nn[i] < k:\n            q.append(i)\n    while q:\n        v = q.popleft()\n        for u in adj[v]:\n            nn[u] -= 1\n            if nn[u] == k-1:\n                q.append(u)\n    res = [0]*m\n    nk = len([1 for i in nn if i >= k])\n    res[-1] = nk\n    for i in range(m-1, 0, -1):\n        u1, v1 = uv[i]\n        if nn[u1] < k or nn[v1] < k:\n            res[i - 1] = nk\n            continue\n        if nn[u1] == k:\n            q.append(u1)\n            nn[u1] -= 1\n        if not q and nn[v1] == k:\n            q.append(v1)\n            nn[v1] -= 1\n        if not q:\n            nn[u1] -= 1\n            nn[v1] -= 1\n            adj[u1].remove(v1)\n            adj[v1].remove(u1)\n        while q:\n            v = q.popleft()\n            nk -= 1\n            for u in adj[v]:\n                nn[u] -= 1\n                if nn[u] == k - 1:\n                    q.append(u)\n        res[i - 1] = nk\n    return res\nn, m, k = map(int, input().split())\na = [set() for i in range(n)]\nuv = []\nfor i in range(m):\n    u, v = map(int, input().split())\n    a[u - 1].add(v - 1)\n    a[v - 1].add(u - 1)\n    uv.append((u-1, v-1))\nres = solve(a, m, k, uv)\nprint(str(res)[1:-1].replace(' ', '').replace(',', '\\n'))","normalized_code":"FUNC_DEF ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR ASSIGN VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR VAR IF VAR VAR VAR EXPR FUNC_CALL VAR VAR WHILE VAR ASSIGN VAR FUNC_CALL VAR FOR VAR VAR VAR VAR VAR NUMBER IF VAR VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR ASSIGN VAR BIN_OP LIST NUMBER VAR ASSIGN VAR FUNC_CALL VAR NUMBER VAR VAR VAR VAR ASSIGN VAR NUMBER VAR FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER NUMBER NUMBER ASSIGN VAR VAR VAR VAR IF VAR VAR VAR VAR VAR VAR ASSIGN VAR BIN_OP VAR NUMBER VAR IF VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR VAR NUMBER IF VAR VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR VAR NUMBER IF VAR VAR VAR NUMBER VAR VAR NUMBER EXPR FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR WHILE VAR ASSIGN VAR FUNC_CALL VAR VAR NUMBER FOR VAR VAR VAR VAR VAR NUMBER IF VAR VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR ASSIGN VAR BIN_OP VAR NUMBER VAR RETURN VAR ASSIGN VAR VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR FUNC_CALL VAR VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER EXPR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER EXPR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR VAR VAR VAR EXPR FUNC_CALL VAR FUNC_CALL FUNC_CALL FUNC_CALL VAR VAR NUMBER NUMBER STRING STRING STRING STRING","self_reflection":"```xml\n<key_elements>\n    <task>For each day, determine the maximum number of people that can go on a trip such that each person either does not go or has at least k friends in the group.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of people\" unit=\"people\" \/>\n        <variable name=\"m\" description=\"Number of days\" unit=\"days\" \/>\n        <variable name=\"k\" description=\"Minimum number of friends each person must have in the group\" unit=\"people\" \/>\n        <variable name=\"x\" description=\"Person x\" unit=\"person\" \/>\n        <variable name=\"y\" description=\"Person y\" unit=\"person\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>2 \u2264 n \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>1 \u2264 m \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>1 \u2264 k < n<\/constraint>\n        <constraint>1 \u2264 x, y \u2264 n<\/constraint>\n        <constraint>x \u2260 y<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains three integers n, m, and k.\n        The next m lines contain two integers x and y, indicating that persons x and y become friends on the morning of day i.\n    <\/input>\n    <output>\n        Print exactly m lines, where the i-th line contains the maximum number of people that can go on the trip on the evening of day i.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        For each day, find the maximum number of people that can go on the trip such that each person either does not go or has at least k friends in the group.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Let's call a string a phone number if it has length 11 and fits the pattern \"8xxxxxxxxxx\", where each \"x\" is replaced by a digit.\nFor example, \"80123456789\" and \"80000000000\" are phone numbers, while \"8012345678\" and \"79000000000\" are not.\nYou have n cards with digits, and you want to use them to make as many phone numbers as possible. Each card must be used in at most one phone number, and you don't have to use all cards. The phone numbers do not necessarily have to be distinct.\nInput\nThe first line contains an integer n \u2014 the number of cards with digits that you have (1 \u2264 n \u2264 100).\nThe second line contains a string of n digits (characters \"0\", \"1\", ..., \"9\") s_1, s_2, \u2026, s_n. The string will not contain any other characters, such as leading or trailing spaces.\nOutput\nIf at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.\nExamples\nInput\n11\n00000000008\nOutput\n1\nInput\n22\n0011223344556677889988\nOutput\n2\nInput\n11\n31415926535\nOutput\n0\nNote\nIn the first example, one phone number, \"8000000000\", can be made from these cards.\nIn the second example, you can make two phone numbers from the cards, for example, \"80123456789\" and \"80123456789\".\nIn the third example you can't make any phone number from the given cards.","sample_inputs":"22\n0011223344556677889988\n11\n00000000008\n11\n31415926535\n","sample_outputs":"2\n1\n0\n","cf_tags":["brute force"],"original_code":"n = int(input())\ns = input()\nk = s.count(\"8\")\nl = n - k\nif k <= l\/\/10: print(k)\nelse:\n    while k > l\/\/10:\n        k -= 1\n        l += 1\n    print(min(k, l\/\/10))\n","cleaned_code":"n = int(input())\ns = input()\nk = s.count(\"8\")\nl = n - k\nif k <= l\/\/10: print(k)\nelse:\n    while k > l\/\/10:\n        k -= 1\n        l += 1\n    print(min(k, l\/\/10))\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR STRING ASSIGN VAR BIN_OP VAR VAR IF VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR WHILE VAR BIN_OP VAR NUMBER VAR NUMBER VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR VAR BIN_OP VAR NUMBER","self_reflection":"```xml\n<key_elements>\n    <task>Find the maximum number of phone numbers that can be made from a given set of cards, where each phone number must start with \"8\" and be 11 digits long.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The number of cards with digits that you have\" unit=\"integer\" range=\"1 \u2264 n \u2264 100\" \/>\n        <variable name=\"s\" description=\"A string of n digits (characters '0', '1', ..., '9')\" unit=\"string\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>Each card must be used in at most one phone number.<\/constraint>\n        <constraint>The phone numbers do not necessarily have to be distinct.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains an integer n \u2014 the number of cards with digits that you have (1 \u2264 n \u2264 100).\n        The second line contains a string of n digits (characters \"0\", \"1\", ..., \"9\") s_1, s_2, \u2026, s_n. The string will not contain any other characters, such as leading or trailing spaces.\n    <\/input>\n    <output>\n        If at least one phone number can be made from these cards, output the maximum number of phone numbers that can be made. Otherwise, output 0.\n    <\/output>\n    <formulas>\n        <!-- No mathematical formulas are explicitly given in the problem statement. -->\n    <\/formulas>\n    <logic_flow>\n        Determine the maximum number of phone numbers that can be formed using the given digits, ensuring each phone number starts with \"8\" and is 11 digits long. Each card can only be used once.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given q queries in the following form:\nGiven three integers l_i, r_i and d_i, find minimum positive integer x_i such that it is divisible by d_i and it does not belong to the segment [l_i, r_i].\nCan you answer all the queries?\nRecall that a number x belongs to segment [l, r] if l \u2264 x \u2264 r.\nInput\nThe first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of queries.\nThen q lines follow, each containing a query given in the format l_i r_i d_i (1 \u2264 l_i \u2264 r_i \u2264 10^9, 1 \u2264 d_i \u2264 10^9). l_i, r_i and d_i are integers.\nOutput\nFor each query print one integer: the answer to this query.\nExample\nInput\n5\n2 4 2\n5 10 4\n3 10 1\n1 2 3\n4 6 5\nOutput\n6\n4\n1\n3\n10","sample_inputs":"5\n2 4 2\n5 10 4\n3 10 1\n1 2 3\n4 6 5\n","sample_outputs":"6\n4\n1\n3\n10\n","cf_tags":["math"],"original_code":"n = int(input())\nA = []\nfor i in range(n):\n    A = A+[input().split()]\nfor a in A:\n    if int(a[2]) < int(a[0]) or int(a[2]) > int(a[1]):\n        print(a[2])\n    else:\n        print(int(a[2])*(int(a[1])\/\/int(a[2])+1))\n","cleaned_code":"n = int(input())\nA = []\nfor i in range(n):\n    A = A+[input().split()]\nfor a in A:\n    if int(a[2]) < int(a[0]) or int(a[2]) > int(a[1]):\n        print(a[2])\n    else:\n        print(int(a[2])*(int(a[1])\/\/int(a[2])+1))\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR BIN_OP VAR LIST FUNC_CALL FUNC_CALL VAR FOR VAR VAR IF FUNC_CALL VAR VAR NUMBER FUNC_CALL VAR VAR NUMBER FUNC_CALL VAR VAR NUMBER FUNC_CALL VAR VAR NUMBER EXPR FUNC_CALL VAR VAR NUMBER EXPR FUNC_CALL VAR BIN_OP FUNC_CALL VAR VAR NUMBER BIN_OP BIN_OP FUNC_CALL VAR VAR NUMBER FUNC_CALL VAR VAR NUMBER NUMBER","self_reflection":"```xml\n<key_elements>\n    <task>Find the minimum positive integer x_i such that it is divisible by d_i and it does not belong to the segment [l_i, r_i] for each query.<\/task>\n    <variables>\n        <variable name=\"q\" description=\"Number of queries\" unit=\"queries\" \/>\n        <variable name=\"l_i\" description=\"Start of the segment\" unit=\"integer\" \/>\n        <variable name=\"r_i\" description=\"End of the segment\" unit=\"integer\" \/>\n        <variable name=\"d_i\" description=\"Divisor\" unit=\"integer\" \/>\n        <variable name=\"x_i\" description=\"Minimum positive integer divisible by d_i and not in [l_i, r_i]\" unit=\"integer\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 q \u2264 500<\/constraint>\n        <constraint>1 \u2264 l_i \u2264 r_i \u2264 10^9<\/constraint>\n        <constraint>1 \u2264 d_i \u2264 10^9<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains one integer q (1 \u2264 q \u2264 500) \u2014 the number of queries.\n        Then q lines follow, each containing a query given in the format l_i r_i d_i (1 \u2264 l_i \u2264 r_i \u2264 10^9, 1 \u2264 d_i \u2264 10^9).\n    <\/input>\n    <output>\n        For each query print one integer: the answer to this query.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        For each query, find the smallest positive integer x_i that is divisible by d_i and not within the range [l_i, r_i].\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Note that this is the first problem of the two similar problems. You can hack this problem only if you solve both problems.\nYou are given a tree with n nodes. In the beginning, 0 is written on all edges. In one operation, you can choose any 2 distinct leaves u, v and any real number x and add x to values written on all edges on the simple path between u and v.\nFor example, on the picture below you can see the result of applying two operations to the graph: adding 2 on the path from 7 to 6, and then adding -0.5 on the path from 4 to 5. \n<image>\nIs it true that for any configuration of real numbers written on edges, we can achieve it with a finite number of operations?\nLeaf is a node of a tree of degree 1. Simple path is a path that doesn't contain any node twice.\nInput\nThe first line contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of nodes.\nEach of the next n-1 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v), meaning that there is an edge between nodes u and v. It is guaranteed that these edges form a tree.\nOutput\nIf there is a configuration of real numbers written on edges of the tree that we can't achieve by performing the operations, output \"NO\". \nOtherwise, output \"YES\". \nYou can print each letter in any case (upper or lower).\nExamples\nInput\n2\n1 2\nOutput\nYES\nInput\n3\n1 2\n2 3\nOutput\nNO\nInput\n5\n1 2\n1 3\n1 4\n2 5\nOutput\nNO\nInput\n6\n1 2\n1 3\n1 4\n2 5\n2 6\nOutput\nYES\nNote\nIn the first example, we can add any real x to the value written on the only edge (1, 2).\n<image>\nIn the second example, one of configurations that we can't reach is 0 written on (1, 2) and 1 written on (2, 3).\n<image>\nBelow you can see graphs from examples 3, 4:\n<image> <image>","sample_inputs":"2\n1 2\n3\n1 2\n2 3\n5\n1 2\n1 3\n1 4\n2 5\n6\n1 2\n1 3\n1 4\n2 5\n2 6\n","sample_outputs":"YESNONOYES","cf_tags":["trees"],"original_code":"m = int(input())\nl = [0 for _ in range(m + 1)]\nfor _ in range(m - 1):\n\ta,b = map(int, input().split())\n\tl[a] += 1\n\tl[b] += 1\nif 2 in l:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")\n\n","cleaned_code":"m = int(input())\nl = [0 for _ in range(m + 1)]\nfor _ in range(m - 1):\n\ta,b = map(int, input().split())\n\tl[a] += 1\n\tl[b] += 1\nif 2 in l:\n\tprint(\"NO\")\nelse:\n\tprint(\"YES\")\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR NUMBER VAR FUNC_CALL VAR BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR VAR VAR NUMBER VAR VAR NUMBER IF NUMBER VAR EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING","self_reflection":"```xml\n<key_elements>\n    <task>Determine if any configuration of real numbers written on edges of a tree can be achieved by performing a finite number of operations.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The number of nodes in the tree.\" unit=\"integer\" range=\"2 \u2264 n \u2264 10^5\" \/>\n        <variable name=\"edges\" description=\"A list of edges connecting nodes.\" unit=\"list of pairs of integers\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>Edges form a tree.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains a single integer n (2 \u2264 n \u2264 10^5) \u2014 the number of nodes.\n        Each of the next n-1 lines contains two integers u and v (1 \u2264 u, v \u2264 n, u \u2260 v), meaning that there is an edge between nodes u and v.\n    <\/input>\n    <output>\n        If there is a configuration of real numbers written on edges of the tree that we can't achieve by performing the operations, output \"NO\".\n        Otherwise, output \"YES\".\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement. -->\n    <\/formulas>\n    <logic_flow>\n        Determine if it is possible to achieve any configuration of real numbers on the edges of the tree using the given operations.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"An array of integers p_{1},p_{2}, \u2026,p_{n} is called a permutation if it contains each number from 1 to n exactly once. For example, the following arrays are permutations: [3,1,2], [1], [1,2,3,4,5] and [4,3,1,2]. The following arrays are not permutations: [2], [1,1], [2,3,4].\nThere is a hidden permutation of length n.\nFor each index i, you are given s_{i}, which equals to the sum of all p_{j} such that j < i and p_{j} < p_{i}. In other words, s_i is the sum of elements before the i-th element that are smaller than the i-th element.\nYour task is to restore the permutation.\nInput\nThe first line contains a single integer n (1 \u2264 n \u2264 2 \u22c5 10^{5}) \u2014 the size of the permutation.\nThe second line contains n integers s_{1}, s_{2}, \u2026, s_{n} (0 \u2264 s_{i} \u2264 (n(n-1))\/(2)).\nIt is guaranteed that the array s corresponds to a valid permutation of length n.\nOutput\nPrint n integers p_{1}, p_{2}, \u2026, p_{n} \u2014 the elements of the restored permutation. We can show that the answer is always unique.\nExamples\nInput\n3\n0 0 0\nOutput\n3 2 1\nInput\n2\n0 1\nOutput\n1 2\nInput\n5\n0 1 1 1 10\nOutput\n1 4 3 2 5\nNote\nIn the first example for each i there is no index j satisfying both conditions, hence s_i are always 0.\nIn the second example for i = 2 it happens that j = 1 satisfies the conditions, so s_2 = p_1.\nIn the third example for i = 2, 3, 4 only j = 1 satisfies the conditions, so s_2 = s_3 = s_4 = 1. For i = 5 all j = 1, 2, 3, 4 are possible, so s_5 = p_1 + p_2 + p_3 + p_4 = 10.","sample_inputs":"3\n0 0 0\n5\n0 1 1 1 10\n2\n0 1\n","sample_outputs":"3 2 1 1 4 3 2 5 1 2 ","cf_tags":["binary search","data structures","greedy","implementation"],"original_code":"from sys import stdin,stdout\n\nclass Tree(object):\n    def __init__(self,n):\n        self.tree=[0]*(4*n+10)\n        self.b=[0]*(n+10)\n        self.a=list(map(int,stdin.readline().split()))\n        self.n=n\n    def update(self,L,C,l,r,rt):\n        if l==r:\n            self.tree[rt]+=C\n            return\n        mid=(l+r)\/\/2\n        if L<=mid:\n            self.update(L,C,l,mid,rt<<1)\n        else:\n            self.update(L,C,mid+1,r,rt<<1|1)\n        self.tree[rt]=self.tree[rt<<1]+self.tree[rt<<1|1]\n\n\n    def query(self,s,l,r,rt):\n        if l==r:\n            return l\n        mid=(l+r)\/\/2\n        if self.tree[rt<<1]>s:\n            return self.query(s,l,mid,rt<<1)\n        else:\n            return self.query(s-self.tree[rt<<1],mid+1,r,rt<<1|1)\n    def slove(self):\n\n        for i in range(n):\n            self.update(i+1,i+1,1,n,1)\n        for i in range(n,0,-1):\n            self.b[i]=self.query(self.a[i-1],1,n,1)\n            self.update(self.b[i],-self.b[i],1,n,1)\n        for i in range(n):\n            stdout.write('%d '%(self.b[i+1]))\n\n\n\n\nif __name__ == '__main__':\n    n=int(stdin.readline())\n    seg=Tree(n)\n    seg.slove()","cleaned_code":"from sys import stdin,stdout\nclass Tree(object):\n    def __init__(self,n):\n        self.tree=[0]*(4*n+10)\n        self.b=[0]*(n+10)\n        self.a=list(map(int,stdin.readline().split()))\n        self.n=n\n    def update(self,L,C,l,r,rt):\n        if l==r:\n            self.tree[rt]+=C\n            return\n        mid=(l+r)\/\/2\n        if L<=mid:\n            self.update(L,C,l,mid,rt<<1)\n        else:\n            self.update(L,C,mid+1,r,rt<<1|1)\n        self.tree[rt]=self.tree[rt<<1]+self.tree[rt<<1|1]\n    def query(self,s,l,r,rt):\n        if l==r:\n            return l\n        mid=(l+r)\/\/2\n        if self.tree[rt<<1]>s:\n            return self.query(s,l,mid,rt<<1)\n        else:\n            return self.query(s-self.tree[rt<<1],mid+1,r,rt<<1|1)\n    def slove(self):\n        for i in range(n):\n            self.update(i+1,i+1,1,n,1)\n        for i in range(n,0,-1):\n            self.b[i]=self.query(self.a[i-1],1,n,1)\n            self.update(self.b[i],-self.b[i],1,n,1)\n        for i in range(n):\n            stdout.write('%d '%(self.b[i+1]))\nif __name__ == '__main__':\n    n=int(stdin.readline())\n    seg=Tree(n)\n    seg.slove()","normalized_code":"CLASS_DEF VAR FUNC_DEF ASSIGN VAR BIN_OP LIST NUMBER BIN_OP BIN_OP NUMBER VAR NUMBER ASSIGN VAR BIN_OP LIST NUMBER BIN_OP VAR NUMBER ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR VAR FUNC_DEF IF VAR VAR VAR VAR VAR RETURN ASSIGN VAR BIN_OP BIN_OP VAR VAR NUMBER IF VAR VAR EXPR FUNC_CALL VAR VAR VAR VAR VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR VAR BIN_OP VAR NUMBER VAR BIN_OP BIN_OP VAR NUMBER NUMBER ASSIGN VAR VAR BIN_OP VAR BIN_OP VAR NUMBER VAR BIN_OP BIN_OP VAR NUMBER NUMBER FUNC_DEF IF VAR VAR RETURN VAR ASSIGN VAR BIN_OP BIN_OP VAR VAR NUMBER IF VAR BIN_OP VAR NUMBER VAR RETURN FUNC_CALL VAR VAR VAR VAR BIN_OP VAR NUMBER RETURN FUNC_CALL VAR BIN_OP VAR VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR BIN_OP BIN_OP VAR NUMBER NUMBER FUNC_DEF FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER NUMBER VAR NUMBER FOR VAR FUNC_CALL VAR VAR NUMBER NUMBER ASSIGN VAR VAR FUNC_CALL VAR VAR BIN_OP VAR NUMBER NUMBER VAR NUMBER EXPR FUNC_CALL VAR VAR VAR VAR VAR NUMBER VAR NUMBER FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR BIN_OP STRING VAR BIN_OP VAR NUMBER IF VAR STRING ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR","self_reflection":"```xml\n<key_elements>\n    <task>Restore the permutation given the sum of elements before each index that are smaller than the element at that index.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The size of the permutation\" unit=\"integer\" \/>\n        <variable name=\"s_i\" description=\"The sum of all p_j such that j < i and p_j < p_i\" unit=\"integer\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>0 \u2264 s_i \u2264 (n(n-1))\/2<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains a single integer n.\n        The second line contains n integers s_1, s_2, ..., s_n.\n    <\/input>\n    <output>\n        Print n integers p_1, p_2, ..., p_n \u2014 the elements of the restored permutation.\n    <\/output>\n    <formulas>\n        s_i = sum(p_j for j < i and p_j < p_i)\n    <\/formulas>\n    <logic_flow>\n        Restore the permutation based on the given sums s_i.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"This is the easier version of the problem. In this version 1 \u2264 n, m \u2264 100. You can hack this problem only if you solve and lock both problems.\nYou are given a sequence of integers a=[a_1,a_2,...,a_n] of length n. Its subsequence is obtained by removing zero or more elements from the sequence a (they do not necessarily go consecutively). For example, for the sequence a=[11,20,11,33,11,20,11]:\n  * [11,20,11,33,11,20,11], [11,20,11,33,11,20], [11,11,11,11], [20], [33,20] are subsequences (these are just some of the long list); \n  * [40], [33,33], [33,20,20], [20,20,11,11] are not subsequences. \nSuppose that an additional non-negative integer k (1 \u2264 k \u2264 n) is given, then the subsequence is called optimal if:\n  * it has a length of k and the sum of its elements is the maximum possible among all subsequences of length k; \n  * and among all subsequences of length k that satisfy the previous item, it is lexicographically minimal. \nRecall that the sequence b=[b_1, b_2, ..., b_k] is lexicographically smaller than the sequence c=[c_1, c_2, ..., c_k] if the first element (from the left) in which they differ less in the sequence b than in c. Formally: there exists t (1 \u2264 t \u2264 k) such that b_1=c_1, b_2=c_2, ..., b_{t-1}=c_{t-1} and at the same time b_t<c_t. For example:\n  * [10, 20, 20] lexicographically less than [10, 21, 1], \n  * [7, 99, 99] is lexicographically less than [10, 21, 1], \n  * [10, 21, 0] is lexicographically less than [10, 21, 1]. \nYou are given a sequence of a=[a_1,a_2,...,a_n] and m requests, each consisting of two numbers k_j and pos_j (1 \u2264 k \u2264 n, 1 \u2264 pos_j \u2264 k_j). For each query, print the value that is in the index pos_j of the optimal subsequence of the given sequence a for k=k_j.\nFor example, if n=4, a=[10,20,30,20], k_j=2, then the optimal subsequence is [20,30] \u2014 it is the minimum lexicographically among all subsequences of length 2 with the maximum total sum of items. Thus, the answer to the request k_j=2, pos_j=1 is the number 20, and the answer to the request k_j=2, pos_j=2 is the number 30.\nInput\nThe first line contains an integer n (1 \u2264 n \u2264 100) \u2014 the length of the sequence a.\nThe second line contains elements of the sequence a: integer numbers a_1, a_2, ..., a_n (1 \u2264 a_i \u2264 10^9).\nThe third line contains an integer m (1 \u2264 m \u2264 100) \u2014 the number of requests.\nThe following m lines contain pairs of integers k_j and pos_j (1 \u2264 k \u2264 n, 1 \u2264 pos_j \u2264 k_j) \u2014 the requests.\nOutput\nPrint m integers r_1, r_2, ..., r_m (1 \u2264 r_j \u2264 10^9) one per line: answers to the requests in the order they appear in the input. The value of r_j should be equal to the value contained in the position pos_j of the optimal subsequence for k=k_j.\nExamples\nInput\n3\n10 20 10\n6\n1 1\n2 1\n2 2\n3 1\n3 2\n3 3\nOutput\n20\n10\n20\n10\n20\n10\nInput\n7\n1 2 1 3 1 2 1\n9\n2 1\n2 2\n3 1\n3 2\n3 3\n1 1\n7 1\n7 7\n7 4\nOutput\n2\n3\n2\n3\n2\n3\n1\n1\n3\nNote\nIn the first example, for a=[10,20,10] the optimal subsequences are: \n  * for k=1: [20], \n  * for k=2: [10,20], \n  * for k=3: [10,20,10]. ","sample_inputs":"3\n10 20 10\n6\n1 1\n2 1\n2 2\n3 1\n3 2\n3 3\n7\n1 2 1 3 1 2 1\n9\n2 1\n2 2\n3 1\n3 2\n3 3\n1 1\n7 1\n7 7\n7 4\n","sample_outputs":"20\n10\n20\n10\n20\n10\n2\n3\n2\n3\n2\n3\n1\n1\n3\n","cf_tags":["data structures","greedy"],"original_code":"# class SegmentTree(): # adapted from https:\/\/www.geeksforgeeks.org\/segment-tree-efficient-implementation\/\n#     def __init__(self,arr,func,initialRes=0):\n#         self.f=func\n#         self.N=len(arr) \n#         self.tree=[0 for _ in range(2*self.N)]\n#         self.initialRes=initialRes\n#         for i in range(self.N):\n#             self.tree[self.N+i]=arr[i]\n#         for i in range(self.N-1,0,-1):\n#             self.tree[i]=self.f(self.tree[i<<1],self.tree[i<<1|1])\n#     def updateTreeNode(self,idx,value): #update value at arr[idx]\n#         self.tree[idx+self.N]=value\n#         idx+=self.N\n#         i=idx\n#         while i>1:\n#             self.tree[i>>1]=self.f(self.tree[i],self.tree[i^1])\n#             i>>=1\n#     def query(self,l,r): #get sum (or whatever function) on interval [l,r] inclusive\n#         r+=1\n#         res=self.initialRes\n#         l+=self.N\n#         r+=self.N\n#         while l<r:\n#             if l&1:\n#                 res=self.f(res,self.tree[l])\n#                 l+=1\n#             if r&1:\n#                 r-=1\n#                 res=self.f(res,self.tree[r])\n#             l>>=1\n#             r>>=1\n#         return res\n# def getMaxSegTree(arr):\n#     return SegmentTree(arr,lambda a,b:max(a,b),initialRes=-float('inf'))\n# def getMinSegTree(arr):\n#     return SegmentTree(arr,lambda a,b:min(a,b),initialRes=float('inf'))\n# def getSumSegTree(arr):\n#     return SegmentTree(arr,lambda a,b:a+b,initialRes=0)\nfrom collections import Counter\ndef main():\n    \n    # mlogn solution\n    n=int(input())\n    a=readIntArr()\n    \n    b=sorted(a,reverse=True)\n    \n    m=int(input())\n    allans=[]\n    for _ in range(m):\n        k,pos=readIntArr()\n        cnt=Counter(b[:k])\n        totalCnts=0\n        for x in a:\n            if cnt[x]>0:\n                cnt[x]-=1\n                totalCnts+=1\n                if totalCnts==pos:\n                    allans.append(x)\n                    break\n    multiLineArrayPrint(allans)\n    \n    return\n\nimport sys\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\n \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n# def readFloatArr():\n#     return [float(x) for x in input().split()]\n\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\n \ndef queryInteractive(i,j):\n    print('? {} {}'.format(i,j))\n    sys.stdout.flush()\n    return int(input())\n \ndef answerInteractive(ans):\n    print('! {}'.format(' '.join([str(x) for x in ans])))\n    sys.stdout.flush()\n \ninf=float('inf')\nMOD=10**9+7\n# MOD=998244353\n \n \nfor _abc in range(1):\n    main()","cleaned_code":"\nfrom collections import Counter\ndef main():\n    # mlogn solution\n    n=int(input())\n    a=readIntArr()\n    b=sorted(a,reverse=True)\n    m=int(input())\n    allans=[]\n    for _ in range(m):\n        k,pos=readIntArr()\n        cnt=Counter(b[:k])\n        totalCnts=0\n        for x in a:\n            if cnt[x]>0:\n                cnt[x]-=1\n                totalCnts+=1\n                if totalCnts==pos:\n                    allans.append(x)\n                    break\n    multiLineArrayPrint(allans)\n    return\nimport sys\ninput=sys.stdin.buffer.readline \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\ndef readIntArr():\n    return [int(x) for x in input().split()]\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\n    dv=defaultValFactory;da=dimensionArr\n    if len(da)==1:return [dv() for _ in range(da[0])]\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\ndef queryInteractive(i,j):\n    print('? {} {}'.format(i,j))\n    sys.stdout.flush()\n    return int(input())\ndef answerInteractive(ans):\n    print('! {}'.format(' '.join([str(x) for x in ans])))\n    sys.stdout.flush()\ninf=float('inf')\nMOD=10**9+7\nfor _abc in range(1):\n    main()","normalized_code":"FUNC_DEF ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR VAR ASSIGN VAR NUMBER FOR VAR VAR IF VAR VAR NUMBER VAR VAR NUMBER VAR NUMBER IF VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR RETURN IMPORT ASSIGN VAR VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR VAR VAR FUNC_DEF RETURN FUNC_CALL VAR VAR VAR FUNC_CALL FUNC_CALL VAR FUNC_DEF ASSIGN VAR VAR ASSIGN VAR VAR IF FUNC_CALL VAR VAR NUMBER RETURN FUNC_CALL VAR VAR FUNC_CALL VAR VAR NUMBER RETURN FUNC_CALL VAR VAR VAR NUMBER VAR FUNC_CALL VAR VAR NUMBER FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING VAR VAR EXPR FUNC_CALL VAR RETURN FUNC_CALL VAR FUNC_CALL VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR EXPR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR STRING ASSIGN VAR BIN_OP BIN_OP NUMBER NUMBER NUMBER FOR VAR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the value at a specified position in the optimal subsequence of a given length for each query.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Length of the sequence a\" unit=\"integer\" range=\"1 \u2264 n \u2264 100\"\/>\n        <variable name=\"a\" description=\"Sequence of integers\" unit=\"integer\" range=\"1 \u2264 a_i \u2264 10^9\"\/>\n        <variable name=\"m\" description=\"Number of requests\" unit=\"integer\" range=\"1 \u2264 m \u2264 100\"\/>\n        <variable name=\"k_j\" description=\"Length of the subsequence for the j-th request\" unit=\"integer\" range=\"1 \u2264 k_j \u2264 n\"\/>\n        <variable name=\"pos_j\" description=\"Position in the subsequence for the j-th request\" unit=\"integer\" range=\"1 \u2264 pos_j \u2264 k_j\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n, m \u2264 100<\/constraint>\n        <constraint>1 \u2264 a_i \u2264 10^9<\/constraint>\n        <constraint>1 \u2264 k_j \u2264 n<\/constraint>\n        <constraint>1 \u2264 pos_j \u2264 k_j<\/constraint>\n    <\/constraints>\n    <input>\n        <line>First line: integer n<\/line>\n        <line>Second line: n integers a_1, a_2, ..., a_n<\/line>\n        <line>Third line: integer m<\/line>\n        <line>Following m lines: pairs of integers k_j and pos_j<\/line>\n    <\/input>\n    <output>\n        <description>Print m integers r_1, r_2, ..., r_m<\/description>\n        <description>Each r_j is the value at position pos_j of the optimal subsequence of length k_j<\/description>\n        <description>Output one integer per line<\/description>\n    <\/output>\n    <formulas>\n        <formula>Optimal subsequence is defined as the subsequence of length k with the maximum sum and lexicographically minimal among all such subsequences.<\/formula>\n    <\/formulas>\n    <logic_flow>\n        <step>For each query, find the optimal subsequence of length k_j from the sequence a.<\/step>\n        <step>Retrieve the value at position pos_j from the optimal subsequence.<\/step>\n        <step>Print the retrieved value for each query.<\/step>\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given a permutation p_1, p_2, \u2026, p_n.\nIn one move you can swap two adjacent values.\nYou want to perform a minimum number of moves, such that in the end there will exist a subsegment 1,2,\u2026, k, in other words in the end there should be an integer i, 1 \u2264 i \u2264 n-k+1 such that p_i = 1, p_{i+1} = 2, \u2026, p_{i+k-1}=k.\nLet f(k) be the minimum number of moves that you need to make a subsegment with values 1,2,\u2026,k appear in the permutation.\nYou need to find f(1), f(2), \u2026, f(n).\nInput\nThe first line of input contains one integer n (1 \u2264 n \u2264 200 000): the number of elements in the permutation.\nThe next line of input contains n integers p_1, p_2, \u2026, p_n: given permutation (1 \u2264 p_i \u2264 n).\nOutput\nPrint n integers, the minimum number of moves that you need to make a subsegment with values 1,2,\u2026,k appear in the permutation, for k=1, 2, \u2026, n.\nExamples\nInput\n5\n5 4 3 2 1\nOutput\n0 1 3 6 10 \nInput\n3\n1 2 3\nOutput\n0 0 0 ","sample_inputs":"3\n1 2 3\n5\n5 4 3 2 1\n","sample_outputs":"0 0 0\n0 1 3 6 10\n","cf_tags":["binary search","data structures"],"original_code":"n = int(input())\na = [0] + list(map(int, input().split()))\n\npos, pb, ps = [[0] * (n + 1) for x in range(3)]\n\n\ndef add(bit, i, val):\n    while i <= n:\n        bit[i] += val\n        i += i & -i\n\n\ndef sum(bit, i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i & -i\n    return res\n\n\ndef find(bit, sum):\n    i, t = 0, 0\n    if sum == 0:\n        return 0\n    for k in range(17, -1, -1):\n        i += 1 << k\n        if i <= n and t + bit[i] < sum:\n            t += bit[i]\n        else:\n            i -= 1 << k\n    return i + 1\n\n\nfor i in range(1, n + 1):\n    pos[a[i]] = i\n\ninvSum = 0\ntotalSum = 0\nfor i in range(1, n + 1):\n    totalSum += pos[i]\n    invSum += i - sum(pb, pos[i]) - 1\n    add(pb, pos[i], 1)\n    add(ps, pos[i], pos[i])\n    mid = find(pb, i \/\/ 2)\n    if i % 2 == 1:\n        mid2 = find(pb, i \/\/ 2 + 1)\n        seqSum = (i + 1) * (i \/\/ 2) \/\/ 2\n    else:\n        mid2 = mid\n        seqSum = i * (i \/\/ 2) \/\/ 2\n    leftSum = sum(ps, mid)\n    rightSum = totalSum - sum(ps, mid2)\n    print(rightSum - leftSum - seqSum + invSum, end=\" \")\n","cleaned_code":"n = int(input())\na = [0] + list(map(int, input().split()))\npos, pb, ps = [[0] * (n + 1) for x in range(3)]\ndef add(bit, i, val):\n    while i <= n:\n        bit[i] += val\n        i += i & -i\ndef sum(bit, i):\n    res = 0\n    while i > 0:\n        res += bit[i]\n        i -= i & -i\n    return res\ndef find(bit, sum):\n    i, t = 0, 0\n    if sum == 0:\n        return 0\n    for k in range(17, -1, -1):\n        i += 1 << k\n        if i <= n and t + bit[i] < sum:\n            t += bit[i]\n        else:\n            i -= 1 << k\n    return i + 1\nfor i in range(1, n + 1):\n    pos[a[i]] = i\ninvSum = 0\ntotalSum = 0\nfor i in range(1, n + 1):\n    totalSum += pos[i]\n    invSum += i - sum(pb, pos[i]) - 1\n    add(pb, pos[i], 1)\n    add(ps, pos[i], pos[i])\n    mid = find(pb, i \/\/ 2)\n    if i % 2 == 1:\n        mid2 = find(pb, i \/\/ 2 + 1)\n        seqSum = (i + 1) * (i \/\/ 2) \/\/ 2\n    else:\n        mid2 = mid\n        seqSum = i * (i \/\/ 2) \/\/ 2\n    leftSum = sum(ps, mid)\n    rightSum = totalSum - sum(ps, mid2)\n    print(rightSum - leftSum - seqSum + invSum, end=\" \")\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR BIN_OP LIST NUMBER FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR VAR VAR BIN_OP LIST NUMBER BIN_OP VAR NUMBER VAR FUNC_CALL VAR NUMBER FUNC_DEF WHILE VAR VAR VAR VAR VAR VAR BIN_OP VAR VAR FUNC_DEF ASSIGN VAR NUMBER WHILE VAR NUMBER VAR VAR VAR VAR BIN_OP VAR VAR RETURN VAR FUNC_DEF ASSIGN VAR VAR NUMBER NUMBER IF VAR NUMBER RETURN NUMBER FOR VAR FUNC_CALL VAR NUMBER NUMBER NUMBER VAR BIN_OP NUMBER VAR IF VAR VAR BIN_OP VAR VAR VAR VAR VAR VAR VAR VAR BIN_OP NUMBER VAR RETURN BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER BIN_OP VAR NUMBER ASSIGN VAR VAR VAR VAR ASSIGN VAR NUMBER ASSIGN VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER BIN_OP VAR NUMBER VAR VAR VAR VAR BIN_OP BIN_OP VAR FUNC_CALL VAR VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR VAR VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR BIN_OP VAR NUMBER IF BIN_OP VAR NUMBER NUMBER ASSIGN VAR FUNC_CALL VAR VAR BIN_OP BIN_OP VAR NUMBER NUMBER ASSIGN VAR BIN_OP BIN_OP BIN_OP VAR NUMBER BIN_OP VAR NUMBER NUMBER ASSIGN VAR VAR ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER NUMBER ASSIGN VAR FUNC_CALL VAR VAR VAR ASSIGN VAR BIN_OP VAR FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR BIN_OP BIN_OP BIN_OP VAR VAR VAR VAR STRING","self_reflection":"```xml\n<key_elements>\n    <task>Find the minimum number of moves required to make a subsegment with values 1, 2, ..., k appear in the permutation for k = 1, 2, ..., n.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The number of elements in the permutation\" unit=\"integer\" \/>\n        <variable name=\"p_i\" description=\"The i-th element of the permutation\" unit=\"integer\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n \u2264 200 000<\/constraint>\n        <constraint>1 \u2264 p_i \u2264 n<\/constraint>\n    <\/constraints>\n    <input>\n        The first line of input contains one integer n: the number of elements in the permutation.\n        The next line of input contains n integers p_1, p_2, ..., p_n: the given permutation.\n    <\/input>\n    <output>\n        Print n integers, the minimum number of moves that you need to make a subsegment with values 1, 2, ..., k appear in the permutation, for k=1, 2, ..., n.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        For each k from 1 to n, determine the minimum number of adjacent swaps required to form a subsegment starting from the beginning of the permutation that contains the values 1, 2, ..., k.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"There are n lamps on a line, numbered from 1 to n. Each one has an initial state off (0) or on (1).\nYou're given k subsets A_1, \u2026, A_k of \\{1, 2, ..., n\\}, such that the intersection of any three subsets is empty. In other words, for all 1 \u2264 i_1 < i_2 < i_3 \u2264 k, A_{i_1} \u2229 A_{i_2} \u2229 A_{i_3} = \u2205.\nIn one operation, you can choose one of these k subsets and switch the state of all lamps in it. It is guaranteed that, with the given subsets, it's possible to make all lamps be simultaneously on using this type of operation.\nLet m_i be the minimum number of operations you have to do in order to make the i first lamps be simultaneously on. Note that there is no condition upon the state of other lamps (between i+1 and n), they can be either off or on.\nYou have to compute m_i for all 1 \u2264 i \u2264 n.\nInput\nThe first line contains two integers n and k (1 \u2264 n, k \u2264 3 \u22c5 10^5).\nThe second line contains a binary string of length n, representing the initial state of each lamp (the lamp i is off if s_i = 0, on if s_i = 1).\nThe description of each one of the k subsets follows, in the following format:\nThe first line of the description contains a single integer c (1 \u2264 c \u2264 n) \u2014 the number of elements in the subset.\nThe second line of the description contains c distinct integers x_1, \u2026, x_c (1 \u2264 x_i \u2264 n) \u2014 the elements of the subset.\nIt is guaranteed that: \n  * The intersection of any three subsets is empty; \n  * It's possible to make all lamps be simultaneously on using some operations. \nOutput\nYou must output n lines. The i-th line should contain a single integer m_i \u2014 the minimum number of operations required to make the lamps 1 to i be simultaneously on.\nExamples\nInput\n7 3\n0011100\n3\n1 4 6\n3\n3 4 7\n2\n2 3\nOutput\n1\n2\n3\n3\n3\n3\n3\nInput\n8 6\n00110011\n3\n1 3 8\n5\n1 2 5 6 7\n2\n6 8\n2\n3 5\n2\n4 7\n1\n2\nOutput\n1\n1\n1\n1\n1\n1\n4\n4\nInput\n5 3\n00011\n3\n1 2 3\n1\n4\n3\n3 4 5\nOutput\n1\n1\n1\n1\n1\nInput\n19 5\n1001001001100000110\n2\n2 3\n2\n5 6\n2\n8 9\n5\n12 13 14 15 16\n1\n19\nOutput\n0\n1\n1\n1\n2\n2\n2\n3\n3\n3\n3\n4\n4\n4\n4\n4\n4\n4\n5\nNote\nIn the first example: \n  * For i = 1, we can just apply one operation on A_1, the final states will be 1010110; \n  * For i = 2, we can apply operations on A_1 and A_3, the final states will be 1100110; \n  * For i \u2265 3, we can apply operations on A_1, A_2 and A_3, the final states will be 1111111. \nIn the second example: \n  * For i \u2264 6, we can just apply one operation on A_2, the final states will be 11111101; \n  * For i \u2265 7, we can apply operations on A_1, A_3, A_4, A_6, the final states will be 11111111. ","sample_inputs":"5 3\n00011\n3\n1 2 3\n1\n4\n3\n3 4 5\n8 6\n00110011\n3\n1 3 8\n5\n1 2 5 6 7\n2\n6 8\n2\n3 5\n2\n4 7\n1\n2\n19 5\n1001001001100000110\n2\n2 3\n2\n5 6\n2\n8 9\n5\n12 13 14 15 16\n1\n19\n7 3\n0011100\n3\n1 4 6\n3\n3 4 7\n2\n2 3\n","sample_outputs":"1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n4\n4\n0\n1\n1\n1\n2\n2\n2\n3\n3\n3\n3\n4\n4\n4\n4\n4\n4\n4\n5\n1\n2\n3\n3\n3\n3\n3\n","cf_tags":["dfs and similar","dsu","graphs"],"original_code":"from sys import stdin\ninput = stdin.readline\n\nn , k = [int(i) for i in input().split()]\npairs = [i + k for i in range(k)] + [i for i in range(k)]\ninitial_condition = list(map(lambda x: x == '1',input().strip()))\ndata = [i for i in range(2*k)] \nconstrain = [-1] * (2*k)\nh = [0] * (2*k)\nL = [1] * k + [0] * k\ndp1 = [-1 for i in range(n)]\ndp2 = [-1 for i in range(n)]\nfor i in range(k):\n    input()\n    inp = [int(j) for j in input().split()]\n    for s in inp:\n        if dp1[s-1] == -1:dp1[s-1] = i\n        else:dp2[s-1] = i\n\npfsums = 0\nans = []\n\n\ndef remove_pfsum(s1):\n    global pfsums\n    if constrain[s1] == 1:\n        pfsums -= L[s1]\n    elif constrain[pairs[s1]] == 1:\n        pfsums -= L[pairs[s1]]\n    else:\n        pfsums -= min(L[s1],L[pairs[s1]])\n\ndef sh(i):\n    while i != data[i]:\n        i = data[i]\n    return i\n\ndef upd_pfsum(s1):\n    global pfsums\n    if constrain[s1] == 1:\n        pfsums += L[s1]\n    elif constrain[pairs[s1]] == 1:\n        pfsums += L[pairs[s1]]\n    else:\n        pfsums += min(L[s1],L[pairs[s1]])\n\ndef ms(i,j):\n    i = sh(i) ; j = sh(j)\n    cons = max(constrain[i],constrain[j])\n\n    if h[i] < h[j]:\n        data[i] = j\n        L[j] += L[i]\n        constrain[j] = cons\n        return j\n    else:\n        data[j] = i\n        if h[i] == h[j]:\n            h[i] += 1\n        L[i] += L[j]\n        constrain[i] = cons\n        return i\n\nfor i in range(n):\n    if dp1[i] == -1 and dp2[i] == -1:\n        pass\n    elif dp2[i] == -1:\n        s1 = sh(dp1[i])\n        remove_pfsum(s1)\n        constrain[s1] = 0 if initial_condition[i] else 1\n        constrain[pairs[s1]] = 1 if initial_condition[i] else 0\n        upd_pfsum(s1)\n    else:\n        s1 = sh(dp1[i]) ; s2 = sh(dp2[i])\n        if s1 == s2 or pairs[s1] == s2:\n            pass\n        else:\n            remove_pfsum(s1)\n            remove_pfsum(s2)\n            if initial_condition[i]:\n                new_s1 = ms(s1,s2)\n                new_s2 = ms(pairs[s1],pairs[s2])\n            else:\n                new_s1 = ms(s1,pairs[s2])\n                new_s2 = ms(pairs[s1],s2)\n            pairs[new_s1] = new_s2\n            pairs[new_s2] = new_s1\n            upd_pfsum(new_s1)\n\n    ans.append(pfsums)\n\nfor i in ans:\n    print(i)\n","cleaned_code":"from sys import stdin\ninput = stdin.readline\nn , k = [int(i) for i in input().split()]\npairs = [i + k for i in range(k)] + [i for i in range(k)]\ninitial_condition = list(map(lambda x: x == '1',input().strip()))\ndata = [i for i in range(2*k)] \nconstrain = [-1] * (2*k)\nh = [0] * (2*k)\nL = [1] * k + [0] * k\ndp1 = [-1 for i in range(n)]\ndp2 = [-1 for i in range(n)]\nfor i in range(k):\n    input()\n    inp = [int(j) for j in input().split()]\n    for s in inp:\n        if dp1[s-1] == -1:dp1[s-1] = i\n        else:dp2[s-1] = i\npfsums = 0\nans = []\ndef remove_pfsum(s1):\n    global pfsums\n    if constrain[s1] == 1:\n        pfsums -= L[s1]\n    elif constrain[pairs[s1]] == 1:\n        pfsums -= L[pairs[s1]]\n    else:\n        pfsums -= min(L[s1],L[pairs[s1]])\ndef sh(i):\n    while i != data[i]:\n        i = data[i]\n    return i\ndef upd_pfsum(s1):\n    global pfsums\n    if constrain[s1] == 1:\n        pfsums += L[s1]\n    elif constrain[pairs[s1]] == 1:\n        pfsums += L[pairs[s1]]\n    else:\n        pfsums += min(L[s1],L[pairs[s1]])\ndef ms(i,j):\n    i = sh(i) ; j = sh(j)\n    cons = max(constrain[i],constrain[j])\n    if h[i] < h[j]:\n        data[i] = j\n        L[j] += L[i]\n        constrain[j] = cons\n        return j\n    else:\n        data[j] = i\n        if h[i] == h[j]:\n            h[i] += 1\n        L[i] += L[j]\n        constrain[i] = cons\n        return i\nfor i in range(n):\n    if dp1[i] == -1 and dp2[i] == -1:\n        pass\n    elif dp2[i] == -1:\n        s1 = sh(dp1[i])\n        remove_pfsum(s1)\n        constrain[s1] = 0 if initial_condition[i] else 1\n        constrain[pairs[s1]] = 1 if initial_condition[i] else 0\n        upd_pfsum(s1)\n    else:\n        s1 = sh(dp1[i]) ; s2 = sh(dp2[i])\n        if s1 == s2 or pairs[s1] == s2:\n            pass\n        else:\n            remove_pfsum(s1)\n            remove_pfsum(s2)\n            if initial_condition[i]:\n                new_s1 = ms(s1,s2)\n                new_s2 = ms(pairs[s1],pairs[s2])\n            else:\n                new_s1 = ms(s1,pairs[s2])\n                new_s2 = ms(pairs[s1],s2)\n            pairs[new_s1] = new_s2\n            pairs[new_s2] = new_s1\n            upd_pfsum(new_s1)\n    ans.append(pfsums)\nfor i in ans:\n    print(i)\n","normalized_code":"ASSIGN VAR VAR ASSIGN VAR VAR FUNC_CALL VAR VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR BIN_OP BIN_OP VAR VAR VAR FUNC_CALL VAR VAR VAR VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR STRING FUNC_CALL FUNC_CALL VAR ASSIGN VAR VAR VAR FUNC_CALL VAR BIN_OP NUMBER VAR ASSIGN VAR BIN_OP LIST NUMBER BIN_OP NUMBER VAR ASSIGN VAR BIN_OP LIST NUMBER BIN_OP NUMBER VAR ASSIGN VAR BIN_OP BIN_OP LIST NUMBER VAR BIN_OP LIST NUMBER VAR ASSIGN VAR NUMBER VAR FUNC_CALL VAR VAR ASSIGN VAR NUMBER VAR FUNC_CALL VAR VAR FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR VAR FUNC_CALL FUNC_CALL VAR FOR VAR VAR IF VAR BIN_OP VAR NUMBER NUMBER ASSIGN VAR BIN_OP VAR NUMBER VAR ASSIGN VAR BIN_OP VAR NUMBER VAR ASSIGN VAR NUMBER ASSIGN VAR LIST FUNC_DEF IF VAR VAR NUMBER VAR VAR VAR IF VAR VAR VAR NUMBER VAR VAR VAR VAR VAR FUNC_CALL VAR VAR VAR VAR VAR VAR FUNC_DEF WHILE VAR VAR VAR ASSIGN VAR VAR VAR RETURN VAR FUNC_DEF IF VAR VAR NUMBER VAR VAR VAR IF VAR VAR VAR NUMBER VAR VAR VAR VAR VAR FUNC_CALL VAR VAR VAR VAR VAR VAR FUNC_DEF ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR VAR IF VAR VAR VAR VAR ASSIGN VAR VAR VAR VAR VAR VAR VAR ASSIGN VAR VAR VAR RETURN VAR ASSIGN VAR VAR VAR IF VAR VAR VAR VAR VAR VAR NUMBER VAR VAR VAR VAR ASSIGN VAR VAR VAR RETURN VAR FOR VAR FUNC_CALL VAR VAR IF VAR VAR NUMBER VAR VAR NUMBER IF VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR VAR NUMBER NUMBER ASSIGN VAR VAR VAR VAR VAR NUMBER NUMBER EXPR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR IF VAR VAR VAR VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR IF VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR ASSIGN VAR VAR VAR ASSIGN VAR VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR FOR VAR VAR EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Compute the minimum number of operations required to make the first i lamps simultaneously on for all 1 \u2264 i \u2264 n.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of lamps on a line\" unit=\"lamps\" \/>\n        <variable name=\"k\" description=\"Number of subsets\" unit=\"subsets\" \/>\n        <variable name=\"s\" description=\"Binary string representing the initial state of each lamp\" unit=\"lamp states\" \/>\n        <variable name=\"A_i\" description=\"Subset of {1, 2, ..., n}\" unit=\"subsets\" \/>\n        <variable name=\"c\" description=\"Number of elements in subset A_i\" unit=\"elements\" \/>\n        <variable name=\"x_i\" description=\"Elements of subset A_i\" unit=\"lamp numbers\" \/>\n        <variable name=\"m_i\" description=\"Minimum number of operations to make the first i lamps simultaneously on\" unit=\"operations\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n, k \u2264 3 \u22c5 10^5<\/constraint>\n        <constraint>The intersection of any three subsets is empty<\/constraint>\n        <constraint>It's possible to make all lamps be simultaneously on using some operations<\/constraint>\n    <\/constraints>\n    <input>\n        <line>Two integers n and k (1 \u2264 n, k \u2264 3 \u22c5 10^5)<\/line>\n        <line>Binary string of length n, representing the initial state of each lamp<\/line>\n        <line>k lines, each describing a subset A_i<\/line>\n    <\/input>\n    <output>\n        <line>n lines, each containing a single integer m_i \u2014 the minimum number of operations required to make the lamps 1 to i be simultaneously on<\/line>\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        Compute the minimum number of operations required to make the first i lamps simultaneously on for all 1 \u2264 i \u2264 n, given the initial state of the lamps and k subsets.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"There are n points on a coordinate axis OX. The i-th point is located at the integer point x_i and has a speed v_i. It is guaranteed that no two points occupy the same coordinate. All n points move with the constant speed, the coordinate of the i-th point at the moment t (t can be non-integer) is calculated as x_i + t \u22c5 v_i.\nConsider two points i and j. Let d(i, j) be the minimum possible distance between these two points over any possible moments of time (even non-integer). It means that if two points i and j coincide at some moment, the value d(i, j) will be 0.\nYour task is to calculate the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\nInput\nThe first line of the input contains one integer n (2 \u2264 n \u2264 2 \u22c5 10^5) \u2014 the number of points.\nThe second line of the input contains n integers x_1, x_2, ..., x_n (1 \u2264 x_i \u2264 10^8), where x_i is the initial coordinate of the i-th point. It is guaranteed that all x_i are distinct.\nThe third line of the input contains n integers v_1, v_2, ..., v_n (-10^8 \u2264 v_i \u2264 10^8), where v_i is the speed of the i-th point.\nOutput\nPrint one integer \u2014 the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j) (the sum of minimum distances over all pairs of points).\nExamples\nInput\n3\n1 3 2\n-100 2 3\nOutput\n3\nInput\n5\n2 1 4 3 5\n2 2 2 3 4\nOutput\n19\nInput\n2\n2 1\n-3 0\nOutput\n0","sample_inputs":"3\n1 3 2\n-100 2 3\n2\n2 1\n-3 0\n5\n2 1 4 3 5\n2 2 2 3 4\n","sample_outputs":"3\n0\n19\n","cf_tags":["data structures","divide and conquer","implementation","sortings"],"original_code":"import bisect\n\ndef getsum(tree , i):\n    s = 0\n    i += 1\n    while i>0:\n        s += tree[i]\n        i -= i & (-i)\n    return s\n\ndef updatebit(tree , n , i , v):\n    i+= 1\n    while i <= n:\n        tree[i] += v\n        i += i & (-i)\n\nn = int(input())\nx = list(map(int , input().split()))\nv = list(map(int , input().split()))\np = [[x[i] , v[i]] for i in range(len(x))]\nvs = sorted(list(set(v)))\np = sorted(p , key = lambda i : i[0])\nl = len(vs)\ncnt = [0]*(l+1)\nxs = [0]*(l+1)\nans = 0\n\nfor pnt in p:\n    pos = bisect.bisect_left(vs , pnt[1])\n    ans += getsum(cnt , pos) * pnt[0] - getsum(xs , pos)\n    updatebit(cnt , l , pos , 1)\n    updatebit(xs , l , pos , pnt[0])\n    \n\nprint(ans)\n","cleaned_code":"import bisect\ndef getsum(tree , i):\n    s = 0\n    i += 1\n    while i>0:\n        s += tree[i]\n        i -= i & (-i)\n    return s\ndef updatebit(tree , n , i , v):\n    i+= 1\n    while i <= n:\n        tree[i] += v\n        i += i & (-i)\nn = int(input())\nx = list(map(int , input().split()))\nv = list(map(int , input().split()))\np = [[x[i] , v[i]] for i in range(len(x))]\nvs = sorted(list(set(v)))\np = sorted(p , key = lambda i : i[0])\nl = len(vs)\ncnt = [0]*(l+1)\nxs = [0]*(l+1)\nans = 0\nfor pnt in p:\n    pos = bisect.bisect_left(vs , pnt[1])\n    ans += getsum(cnt , pos) * pnt[0] - getsum(xs , pos)\n    updatebit(cnt , l , pos , 1)\n    updatebit(xs , l , pos , pnt[0])\nprint(ans)\n","normalized_code":"IMPORT FUNC_DEF ASSIGN VAR NUMBER VAR NUMBER WHILE VAR NUMBER VAR VAR VAR VAR BIN_OP VAR VAR RETURN VAR FUNC_DEF VAR NUMBER WHILE VAR VAR VAR VAR VAR VAR BIN_OP VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR LIST VAR VAR VAR VAR VAR FUNC_CALL VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR BIN_OP LIST NUMBER BIN_OP VAR NUMBER ASSIGN VAR BIN_OP LIST NUMBER BIN_OP VAR NUMBER ASSIGN VAR NUMBER FOR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR NUMBER VAR BIN_OP BIN_OP FUNC_CALL VAR VAR VAR VAR NUMBER FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Calculate the sum of minimum distances over all pairs of points on a coordinate axis OX.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of points\" unit=\"integer\" range=\"2 \u2264 n \u2264 2 \u22c5 10^5\" \/>\n        <variable name=\"x_i\" description=\"Initial coordinate of the i-th point\" unit=\"integer\" range=\"1 \u2264 x_i \u2264 10^8\" \/>\n        <variable name=\"v_i\" description=\"Speed of the i-th point\" unit=\"integer\" range=\"-10^8 \u2264 v_i \u2264 10^8\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>Points are distinct in their coordinates.<\/constraint>\n        <constraint>Speeds can be negative.<\/constraint>\n    <\/constraints>\n    <input>\n        <line>First line: integer n (number of points)<\/line>\n        <line>Second line: n integers x_1, x_2, ..., x_n (initial coordinates of the points)<\/line>\n        <line>Third line: n integers v_1, v_2, ..., v_n (speeds of the points)<\/line>\n    <\/input>\n    <output>\n        <description>Print one integer \u2014 the value \u2211_{1 \u2264 i < j \u2264 n} d(i, j)<\/description>\n    <\/output>\n    <formulas>\n        <formula>d(i, j) = min(abs(x_i + t * v_i - (x_j + t * v_j))) for all t<\/formula>\n    <\/formulas>\n    <logic_flow>\n        Calculate the minimum distance between each pair of points over all possible moments of time.\n        Sum these minimum distances for all pairs of points.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given a complete directed graph K_n with n vertices: each pair of vertices u \u2260 v in K_n have both directed edges (u, v) and (v, u); there are no self-loops.\nYou should find such a cycle in K_n that visits every directed edge exactly once (allowing for revisiting vertices).\nWe can write such cycle as a list of n(n - 1) + 1 vertices v_1, v_2, v_3, ..., v_{n(n - 1) - 1}, v_{n(n - 1)}, v_{n(n - 1) + 1} = v_1 \u2014 a visiting order, where each (v_i, v_{i + 1}) occurs exactly once.\nFind the lexicographically smallest such cycle. It's not hard to prove that the cycle always exists.\nSince the answer can be too large print its [l, r] segment, in other words, v_l, v_{l + 1}, ..., v_r.\nInput\nThe first line contains the single integer T (1 \u2264 T \u2264 100) \u2014 the number of test cases.\nNext T lines contain test cases \u2014 one per line. The first and only line of each test case contains three integers n, l and r (2 \u2264 n \u2264 10^5, 1 \u2264 l \u2264 r \u2264 n(n - 1) + 1, r - l + 1 \u2264 10^5) \u2014 the number of vertices in K_n, and segment of the cycle to print.\nIt's guaranteed that the total sum of n doesn't exceed 10^5 and the total sum of r - l + 1 doesn't exceed 10^5.\nOutput\nFor each test case print the segment v_l, v_{l + 1}, ..., v_r of the lexicographically smallest cycle that visits every edge exactly once.\nExample\nInput\n3\n2 1 3\n3 3 6\n99995 9998900031 9998900031\nOutput\n1 2 1 \n1 3 2 3 \n1 \nNote\nIn the second test case, the lexicographically minimum cycle looks like: 1, 2, 1, 3, 2, 3, 1.\nIn the third test case, it's quite obvious that the cycle should start and end in vertex 1.","sample_inputs":"3\n2 1 3\n3 3 6\n99995 9998900031 9998900031\n","sample_outputs":"1 2 1 \n1 3 2 3 \n1 \n","cf_tags":["constructive algorithms","graphs","greedy","implementation"],"original_code":"# -*- coding:utf-8 -*-\n\n\"\"\"\n\ncreated by shuangquan.huang at 2020\/7\/1\n\n\"\"\"\n\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\n\n\n\ndef solve(n, l, r):\n    # 1, 2, 1, 3, ..., 1, n\n    # 2, 3, 2, 4, ..., 2, n\n    # ...\n    # n-1, n\n    # 1\n    \n    lo, hi = 1, n\n    while lo <= hi:\n        k = (lo + hi) \/\/ 2\n        s = k * (2*n-1-k)\n        if s < l:\n            lo = k + 1\n        else:\n            hi = k - 1\n    \n    k = lo\n    s = k * (2*n-1-k)\n    b = k\n    \n    \n    # [b, b+1, b, b+2, ..., b, n]\n    row = []\n    for i in range(b+1, n+1):\n        row.append(b)\n        row.append(i)\n    ans = row[l-s-1:]\n    d = r-l+1\n    if len(ans) >= d:\n        return ans[:d]\n    \n    while len(ans) < d:\n        b += 1\n        row = []\n        for i in range(b + 1, n + 1):\n            row.append(b)\n            row.append(i)\n        if not row:\n            break\n        ans += row\n    \n    ans.append(1)\n    # print(ans[:d])\n    return ans[:d]\n    \n\nif __name__ == '__main__':\n    T = int(input())\n    ans = []\n    for ti in range(T):\n        N, L, R = map(int, input().split())\n        ans.append(solve(N, L, R))\n    print('\\n'.join([' '.join(map(str, v)) for v in ans]))","cleaned_code":"\n\"\"\"\ncreated by shuangquan.huang at 2020\/7\/1\n\"\"\"\nimport collections\nimport time\nimport os\nimport sys\nimport bisect\nimport heapq\nfrom typing import List\ndef solve(n, l, r):\n    # 1, 2, 1, 3, ..., 1, n\n    # 2, 3, 2, 4, ..., 2, n\n    # ...\n    # n-1, n\n    # 1\n    lo, hi = 1, n\n    while lo <= hi:\n        k = (lo + hi) \/\/ 2\n        s = k * (2*n-1-k)\n        if s < l:\n            lo = k + 1\n        else:\n            hi = k - 1\n    k = lo\n    s = k * (2*n-1-k)\n    b = k\n    # [b, b+1, b, b+2, ..., b, n]\n    row = []\n    for i in range(b+1, n+1):\n        row.append(b)\n        row.append(i)\n    ans = row[l-s-1:]\n    d = r-l+1\n    if len(ans) >= d:\n        return ans[:d]\n    while len(ans) < d:\n        b += 1\n        row = []\n        for i in range(b + 1, n + 1):\n            row.append(b)\n            row.append(i)\n        if not row:\n            break\n        ans += row\n    ans.append(1)\n    # print(ans[:d])\n    return ans[:d]\nif __name__ == '__main__':\n    T = int(input())\n    ans = []\n    for ti in range(T):\n        N, L, R = map(int, input().split())\n        ans.append(solve(N, L, R))\n    print('\\n'.join([' '.join(map(str, v)) for v in ans]))","normalized_code":"EXPR STRING IMPORT IMPORT IMPORT IMPORT IMPORT IMPORT FUNC_DEF ASSIGN VAR VAR NUMBER VAR WHILE VAR VAR ASSIGN VAR BIN_OP BIN_OP VAR VAR NUMBER ASSIGN VAR BIN_OP VAR BIN_OP BIN_OP BIN_OP NUMBER VAR NUMBER VAR IF VAR VAR ASSIGN VAR BIN_OP VAR NUMBER ASSIGN VAR BIN_OP VAR NUMBER ASSIGN VAR VAR ASSIGN VAR BIN_OP VAR BIN_OP BIN_OP BIN_OP NUMBER VAR NUMBER VAR ASSIGN VAR VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR ASSIGN VAR VAR BIN_OP BIN_OP VAR VAR NUMBER ASSIGN VAR BIN_OP BIN_OP VAR VAR NUMBER IF FUNC_CALL VAR VAR VAR RETURN VAR VAR WHILE FUNC_CALL VAR VAR VAR VAR NUMBER ASSIGN VAR LIST FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR IF VAR VAR VAR EXPR FUNC_CALL VAR NUMBER RETURN VAR VAR IF VAR STRING ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR EXPR FUNC_CALL VAR FUNC_CALL VAR VAR VAR VAR EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the lexicographically smallest cycle in a complete directed graph K_n that visits every directed edge exactly once, and print a segment of this cycle.<\/task>\n    <variables>\n        <variable name=\"T\" description=\"Number of test cases\" unit=\"count\" \/>\n        <variable name=\"n\" description=\"Number of vertices in K_n\" unit=\"count\" \/>\n        <variable name=\"l\" description=\"Start index of the segment to print\" unit=\"count\" \/>\n        <variable name=\"r\" description=\"End index of the segment to print\" unit=\"count\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 T \u2264 100<\/constraint>\n        <constraint>2 \u2264 n \u2264 10^5<\/constraint>\n        <constraint>1 \u2264 l \u2264 r \u2264 n(n - 1) + 1<\/constraint>\n        <constraint>r - l + 1 \u2264 10^5<\/constraint>\n        <constraint>The total sum of n doesn't exceed 10^5<\/constraint>\n        <constraint>The total sum of r - l + 1 doesn't exceed 10^5<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains the single integer T (number of test cases).\n        Next T lines contain test cases \u2014 one per line. The first and only line of each test case contains three integers n, l and r.\n    <\/input>\n    <output>\n        For each test case print the segment v_l, v_{l + 1}, ..., v_r of the lexicographically smallest cycle that visits every edge exactly once.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        Find the lexicographically smallest cycle in a complete directed graph K_n that visits every directed edge exactly once, and print a segment of this cycle.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Polycarp plays a computer game. In this game, the players summon armies of magical minions, which then fight each other.\nPolycarp can summon n different minions. The initial power level of the i-th minion is a_i, and when it is summoned, all previously summoned minions' power levels are increased by b_i. The minions can be summoned in any order.\nUnfortunately, Polycarp cannot have more than k minions under his control. To get rid of unwanted minions after summoning them, he may destroy them. Each minion can be summoned (and destroyed) only once.\nPolycarp's goal is to summon the strongest possible army. Formally, he wants to maximize the sum of power levels of all minions under his control (those which are summoned and not destroyed).\nHelp Polycarp to make up a plan of actions to summon the strongest possible army!\nInput\nThe first line contains one integer T (1 \u2264 T \u2264 75) \u2014 the number of test cases.\nEach test case begins with a line containing two integers n and k (1 \u2264 k \u2264 n \u2264 75) \u2014 the number of minions availible for summoning, and the maximum number of minions that can be controlled by Polycarp, respectively.\nThen n lines follow, the i-th line contains 2 integers a_i and b_i (1 \u2264 a_i \u2264 10^5, 0 \u2264 b_i \u2264 10^5) \u2014 the parameters of the i-th minion.\nOutput\nFor each test case print the optimal sequence of actions as follows:\nFirstly, print m \u2014 the number of actions which Polycarp has to perform (0 \u2264 m \u2264 2n). Then print m integers o_1, o_2, ..., o_m, where o_i denotes the i-th action as follows: if the i-th action is to summon the minion x, then o_i = x, and if the i-th action is to destroy the minion x, then o_i = -x. Each minion can be summoned at most once and cannot be destroyed before being summoned (and, obviously, cannot be destroyed more than once). The number of minions in Polycarp's army should be not greater than k after every action.\nIf there are multiple optimal sequences, print any of them.\nExample\nInput\n3\n5 2\n5 3\n7 0\n5 0\n4 0\n10 0\n2 1\n10 100\n50 10\n5 5\n1 5\n2 4\n3 3\n4 2\n5 1\nOutput\n4\n2 1 -1 5\n1\n2\n5\n5 4 3 2 1\nNote\nConsider the example test.\nIn the first test case, Polycarp can summon the minion 2 with power level 7, then summon the minion 1, which will increase the power level of the previous minion by 3, then destroy the minion 1, and finally, summon the minion 5. After this, Polycarp will have two minions with power levels of 10.\nIn the second test case, Polycarp can control only one minion, so he should choose the strongest of them and summon it.\nIn the third test case, Polycarp is able to summon and control all five minions.","sample_inputs":"3\n5 2\n5 3\n7 0\n5 0\n4 0\n10 0\n2 1\n10 100\n50 10\n5 5\n1 5\n2 4\n3 3\n4 2\n5 1\n","sample_outputs":"8\n2 3 -3 4 -4 1 -1 5\n3\n1 -1 2\n5\n5 4 3 2 1\n","cf_tags":["constructive algorithms","dp","flows","graph matchings","greedy","sortings"],"original_code":"from sys import stdin, gettrace\nfrom heapq import nlargest\n\nif not gettrace():\n    def input():\n        return next(stdin)[:-1]\n\n\n# def input():\n#    return stdin.buffer.readline()\nINF = int(10E10)\n\ndef main():\n    def solve():\n\n        n, k = map(int, input().split())\n        mm = []\n        for i in range(1,n+1):\n            a,b = map(int, input().split())\n            mm.append((b, a, i))\n        mm.sort()\n        dp = [[(-1000000, False)] * min(i+1,k+1) for i in range(n+1)]\n        dp[1][0] = (mm[0][0] * (k-1), False)\n        dp[1][1] = (mm[0][1], True)\n        for j,(b,a,_) in enumerate(mm[1:],2):\n            dp[j][0] = (dp[j-1][0][0] + b * (k-1), False)\n            for l in range(1, min(j, k+1)):\n                v1 = dp[j-1][l][0] + b * (k-1)\n                v2 = dp[j-1][l-1][0] + a + b * (l-1)\n                if v1 > v2:\n                    dp[j][l] = (v1, False)\n                else:\n                    dp[j][l] = (v2, True)\n            if j <= k:\n                dp[j][j] = (dp[j-1][j-1][0] + a + b * (j-1), True)\n        g1 = []\n        g2 = []\n        l = k\n        for j in range(n, 0, -1):\n            _, _, i = mm[j-1]\n            if dp[j][l][1]:\n                g1.append(i)\n                l -= 1\n            else:\n                g2.append(i)\n                g2.append(-i)\n        g1.reverse()\n        res = g1[:k-1] + g2 + g1[k-1:]\n        print(len(res))\n        print(' '.join(map(str, res)))\n\n    q = int(input())\n    for _ in range(q):\n        solve()\n\n\nif __name__ == \"__main__\":\n    main()","cleaned_code":"from sys import stdin, gettrace\nfrom heapq import nlargest\nif not gettrace():\n    def input():\n        return next(stdin)[:-1]\nINF = int(10E10)\ndef main():\n    def solve():\n        n, k = map(int, input().split())\n        mm = []\n        for i in range(1,n+1):\n            a,b = map(int, input().split())\n            mm.append((b, a, i))\n        mm.sort()\n        dp = [[(-1000000, False)] * min(i+1,k+1) for i in range(n+1)]\n        dp[1][0] = (mm[0][0] * (k-1), False)\n        dp[1][1] = (mm[0][1], True)\n        for j,(b,a,_) in enumerate(mm[1:],2):\n            dp[j][0] = (dp[j-1][0][0] + b * (k-1), False)\n            for l in range(1, min(j, k+1)):\n                v1 = dp[j-1][l][0] + b * (k-1)\n                v2 = dp[j-1][l-1][0] + a + b * (l-1)\n                if v1 > v2:\n                    dp[j][l] = (v1, False)\n                else:\n                    dp[j][l] = (v2, True)\n            if j <= k:\n                dp[j][j] = (dp[j-1][j-1][0] + a + b * (j-1), True)\n        g1 = []\n        g2 = []\n        l = k\n        for j in range(n, 0, -1):\n            _, _, i = mm[j-1]\n            if dp[j][l][1]:\n                g1.append(i)\n                l -= 1\n            else:\n                g2.append(i)\n                g2.append(-i)\n        g1.reverse()\n        res = g1[:k-1] + g2 + g1[k-1:]\n        print(len(res))\n        print(' '.join(map(str, res)))\n    q = int(input())\n    for _ in range(q):\n        solve()\nif __name__ == \"__main__\":\n    main()","normalized_code":"IF FUNC_CALL VAR FUNC_DEF RETURN FUNC_CALL VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR NUMBER FUNC_DEF FUNC_DEF ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR NUMBER BIN_OP VAR NUMBER ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR EXPR FUNC_CALL VAR VAR VAR VAR EXPR FUNC_CALL VAR ASSIGN VAR BIN_OP LIST NUMBER NUMBER FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR NUMBER NUMBER BIN_OP VAR NUMBER NUMBER BIN_OP VAR NUMBER NUMBER ASSIGN VAR NUMBER NUMBER VAR NUMBER NUMBER NUMBER FOR VAR VAR VAR VAR FUNC_CALL VAR VAR NUMBER NUMBER ASSIGN VAR VAR NUMBER BIN_OP VAR BIN_OP VAR NUMBER NUMBER NUMBER BIN_OP VAR BIN_OP VAR NUMBER NUMBER FOR VAR FUNC_CALL VAR NUMBER FUNC_CALL VAR VAR BIN_OP VAR NUMBER ASSIGN VAR BIN_OP VAR BIN_OP VAR NUMBER VAR NUMBER BIN_OP VAR BIN_OP VAR NUMBER ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER NUMBER VAR BIN_OP VAR BIN_OP VAR NUMBER IF VAR VAR ASSIGN VAR VAR VAR VAR NUMBER ASSIGN VAR VAR VAR VAR NUMBER IF VAR VAR ASSIGN VAR VAR VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER NUMBER VAR BIN_OP VAR BIN_OP VAR NUMBER NUMBER ASSIGN VAR LIST ASSIGN VAR LIST ASSIGN VAR VAR FOR VAR FUNC_CALL VAR VAR NUMBER NUMBER ASSIGN VAR VAR VAR VAR BIN_OP VAR NUMBER IF VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR VAR NUMBER EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER VAR VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL VAR VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR IF VAR STRING EXPR FUNC_CALL VAR","self_reflection":"```xml\n<key_elements>\n    <task>Help Polycarp to make up a plan of actions to summon the strongest possible army by maximizing the sum of power levels of all minions under his control, given constraints on the number of minions and the maximum number of minions he can control.<\/task>\n    <variables>\n        <variable name=\"T\" description=\"Number of test cases\" unit=\"count\"\/>\n        <variable name=\"n\" description=\"Number of minions available for summoning\" unit=\"count\"\/>\n        <variable name=\"k\" description=\"Maximum number of minions that can be controlled by Polycarp\" unit=\"count\"\/>\n        <variable name=\"a_i\" description=\"Initial power level of the i-th minion\" unit=\"power\"\/>\n        <variable name=\"b_i\" description=\"Increase in power level of previously summoned minions when the i-th minion is summoned\" unit=\"power\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 T \u2264 75<\/constraint>\n        <constraint>1 \u2264 k \u2264 n \u2264 75<\/constraint>\n        <constraint>1 \u2264 a_i \u2264 10^5<\/constraint>\n        <constraint>0 \u2264 b_i \u2264 10^5<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains one integer T (1 \u2264 T \u2264 75) \u2014 the number of test cases.\n        Each test case begins with a line containing two integers n and k (1 \u2264 k \u2264 n \u2264 75) \u2014 the number of minions available for summoning, and the maximum number of minions that can be controlled by Polycarp, respectively.\n        Then n lines follow, the i-th line contains 2 integers a_i and b_i (1 \u2264 a_i \u2264 10^5, 0 \u2264 b_i \u2264 10^5) \u2014 the parameters of the i-th minion.\n    <\/input>\n    <output>\n        For each test case print the optimal sequence of actions as follows:\n        Firstly, print m \u2014 the number of actions which Polycarp has to perform (0 \u2264 m \u2264 2n). Then print m integers o_1, o_2, ..., o_m, where o_i denotes the i-th action as follows: if the i-th action is to summon the minion x, then o_i = x, and if the i-th action is to destroy the minion x, then o_i = -x. Each minion can be summoned at most once and cannot be destroyed before being summoned (and, obviously, cannot be destroyed more than once). The number of minions in Polycarp's army should be not greater than k after every action.\n        If there are multiple optimal sequences, print any of them.\n    <\/output>\n    <formulas\/>\n    <logic_flow>\n        Determine the optimal sequence of summoning and destroying minions to maximize the sum of power levels of all minions under Polycarp's control, ensuring the number of minions does not exceed k after each action.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Easy and hard versions are actually different problems, so read statements of both problems completely and carefully.\nSummer vacation has started so Alice and Bob want to play and joy, but... Their mom doesn't think so. She says that they have to read some amount of books before all entertainments. Alice and Bob will read each book together to end this exercise faster.\nThere are n books in the family library. The i-th book is described by three integers: t_i \u2014 the amount of time Alice and Bob need to spend to read it, a_i (equals 1 if Alice likes the i-th book and 0 if not), and b_i (equals 1 if Bob likes the i-th book and 0 if not).\nSo they need to choose some books from the given n books in such a way that:\n  * Alice likes at least k books from the chosen set and Bob likes at least k books from the chosen set; \n  * the total reading time of these books is minimized (they are children and want to play and joy as soon a possible). \nThe set they choose is the same for both Alice an Bob (it's shared between them) and they read all books together, so the total reading time is the sum of t_i over all books that are in the chosen set.\nYour task is to help them and find any suitable set of books or determine that it is impossible to find such a set.\nInput\nThe first line of the input contains two integers n and k (1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5).\nThe next n lines contain descriptions of books, one description per line: the i-th line contains three integers t_i, a_i and b_i (1 \u2264 t_i \u2264 10^4, 0 \u2264 a_i, b_i \u2264 1), where:\n  * t_i \u2014 the amount of time required for reading the i-th book; \n  * a_i equals 1 if Alice likes the i-th book and 0 otherwise; \n  * b_i equals 1 if Bob likes the i-th book and 0 otherwise. \nOutput\nIf there is no solution, print only one integer -1. Otherwise print one integer T \u2014 the minimum total reading time of the suitable set of books.\nExamples\nInput\n8 4\n7 1 1\n2 1 1\n4 0 1\n8 1 1\n1 0 1\n1 1 1\n1 0 1\n3 0 0\nOutput\n18\nInput\n5 2\n6 0 0\n9 0 0\n1 0 1\n2 1 1\n5 1 0\nOutput\n8\nInput\n5 3\n3 0 0\n2 1 0\n3 1 0\n5 0 1\n3 0 1\nOutput\n-1","sample_inputs":"8 4\n7 1 1\n2 1 1\n4 0 1\n8 1 1\n1 0 1\n1 1 1\n1 0 1\n3 0 0\n5 2\n6 0 0\n9 0 0\n1 0 1\n2 1 1\n5 1 0\n5 3\n3 0 0\n2 1 0\n3 1 0\n5 0 1\n3 0 1\n","sample_outputs":"18\n8\n-1\n","cf_tags":["data structures","greedy","sortings"],"original_code":"import sys\ninput=sys.stdin.readline\nf=lambda :list(map(int, input().strip('\\n').split()))\n\nn, k=f()\n_11=[]\n_01=[]\n_10=[]\nfor _ in range(n):\n\tt, a, b=f()\n\tif a and b:\n\t\t_11.append(t)\n\telif a:\n\t\t_10.append(t)\n\telif b:\n\t\t_01.append(t)\n_01.sort(); _10.sort(); _11.sort()\nfor i in range(1, len(_01)):\n\t_01[i]+=_01[i-1]\nfor i in range(1, len(_10)):\n\t_10[i]+=_10[i-1]\nfor i in range(1, len(_11)):\n\t_11[i]+=_11[i-1]\nans=3*1e9\nif len(_01)>=k and len(_10)>=k:\n\tans=min(ans, _01[k-1]+_10[k-1])\nfor i in range(len(_11)):\n\tif i+1<k and (len(_01)>=k-i-1) and (len(_10)>=k-i-1):\n\t\tans=min(ans, _11[i]+_01[k-i-2]+_10[k-i-2])\n\telse:\n\t\tif len(_11)>=k:\n\t\t\tans=min(ans, _11[k-1])\n\t\t\tbreak\nprint(-1 if ans==3*1e9 else ans)","cleaned_code":"import sys\ninput=sys.stdin.readline\nf=lambda :list(map(int, input().strip('\\n').split()))\nn, k=f()\n_11=[]\n_01=[]\n_10=[]\nfor _ in range(n):\n\tt, a, b=f()\n\tif a and b:\n\t\t_11.append(t)\n\telif a:\n\t\t_10.append(t)\n\telif b:\n\t\t_01.append(t)\n_01.sort(); _10.sort(); _11.sort()\nfor i in range(1, len(_01)):\n\t_01[i]+=_01[i-1]\nfor i in range(1, len(_10)):\n\t_10[i]+=_10[i-1]\nfor i in range(1, len(_11)):\n\t_11[i]+=_11[i-1]\nans=3*1e9\nif len(_01)>=k and len(_10)>=k:\n\tans=min(ans, _01[k-1]+_10[k-1])\nfor i in range(len(_11)):\n\tif i+1<k and (len(_01)>=k-i-1) and (len(_10)>=k-i-1):\n\t\tans=min(ans, _11[i]+_01[k-i-2]+_10[k-i-2])\n\telse:\n\t\tif len(_11)>=k:\n\t\t\tans=min(ans, _11[k-1])\n\t\t\tbreak\nprint(-1 if ans==3*1e9 else ans)","normalized_code":"IMPORT ASSIGN VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL FUNC_CALL VAR STRING ASSIGN VAR VAR FUNC_CALL VAR ASSIGN VAR LIST ASSIGN VAR LIST ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR FUNC_CALL VAR IF VAR VAR EXPR FUNC_CALL VAR VAR IF VAR EXPR FUNC_CALL VAR VAR IF VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR EXPR FUNC_CALL VAR EXPR FUNC_CALL VAR FOR VAR FUNC_CALL VAR NUMBER FUNC_CALL VAR VAR VAR VAR VAR BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER FUNC_CALL VAR VAR VAR VAR VAR BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER FUNC_CALL VAR VAR VAR VAR VAR BIN_OP VAR NUMBER ASSIGN VAR BIN_OP NUMBER NUMBER IF FUNC_CALL VAR VAR VAR FUNC_CALL VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR BIN_OP VAR BIN_OP VAR NUMBER VAR BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR FUNC_CALL VAR VAR IF BIN_OP VAR NUMBER VAR FUNC_CALL VAR VAR BIN_OP BIN_OP VAR VAR NUMBER FUNC_CALL VAR VAR BIN_OP BIN_OP VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR BIN_OP BIN_OP VAR VAR VAR BIN_OP BIN_OP VAR VAR NUMBER VAR BIN_OP BIN_OP VAR VAR NUMBER IF FUNC_CALL VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR BIN_OP VAR NUMBER EXPR FUNC_CALL VAR VAR BIN_OP NUMBER NUMBER NUMBER VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the minimum total reading time of a set of books that Alice and Bob both like, such that each of them likes at least k books from the set.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The total number of books in the library\" unit=\"books\" \/>\n        <variable name=\"k\" description=\"The minimum number of books each of them must like\" unit=\"books\" \/>\n        <variable name=\"t_i\" description=\"The time required to read the i-th book\" unit=\"time\" \/>\n        <variable name=\"a_i\" description=\"Indicates if Alice likes the i-th book (1 if yes, 0 if no)\" unit=\"boolean\" \/>\n        <variable name=\"b_i\" description=\"Indicates if Bob likes the i-th book (1 if yes, 0 if no)\" unit=\"boolean\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 k \u2264 n \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>1 \u2264 t_i \u2264 10^4<\/constraint>\n        <constraint>0 \u2264 a_i, b_i \u2264 1<\/constraint>\n    <\/constraints>\n    <input>\n        The first line of the input contains two integers n and k.\n        The next n lines contain descriptions of books, one description per line: the i-th line contains three integers t_i, a_i and b_i.\n    <\/input>\n    <output>\n        If there is no solution, print -1. Otherwise, print the minimum total reading time T of the suitable set of books.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        Determine if there exists a subset of books such that both Alice and Bob like at least k books from the subset, and the total reading time of the subset is minimized.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given an array a_1, a_2, ... , a_n, which is sorted in non-decreasing order (a_i \u2264 a_{i + 1}). \nFind three indices i, j, k such that 1 \u2264 i < j < k \u2264 n and it is impossible to construct a non-degenerate triangle (a triangle with nonzero area) having sides equal to a_i, a_j and a_k (for example it is possible to construct a non-degenerate triangle with sides 3, 4 and 5 but impossible with sides 3, 4 and 7). If it is impossible to find such triple, report it.\nInput\nThe first line contains one integer t (1 \u2264 t \u2264 1000) \u2014 the number of test cases.\nThe first line of each test case contains one integer n (3 \u2264 n \u2264 5 \u22c5 10^4) \u2014 the length of the array a.\nThe second line of each test case contains n integers a_1, a_2, ... , a_n (1 \u2264 a_i \u2264 10^9; a_{i - 1} \u2264 a_i) \u2014 the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 10^5.\nOutput\nFor each test case print the answer to it in one line.\nIf there is a triple of indices i, j, k (i < j < k) such that it is impossible to construct a non-degenerate triangle having sides equal to a_i, a_j and a_k, print that three indices in ascending order. If there are multiple answers, print any of them.\nOtherwise, print -1.\nExample\nInput\n3\n7\n4 6 11 11 15 18 20\n4\n10 10 10 11\n3\n1 1 1000000000\nOutput\n2 3 6\n-1\n1 2 3\nNote\nIn the first test case it is impossible with sides 6, 11 and 18. Note, that this is not the only correct answer.\nIn the second test case you always can construct a non-degenerate triangle.","sample_inputs":"3\n7\n4 6 11 11 15 18 20\n4\n10 10 10 11\n3\n1 1 1000000000\n","sample_outputs":"1 2 7\n-1\n1 2 3\n","cf_tags":["geometry","math"],"original_code":"t=int(input())\nfor z in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    min= arr[0] + arr[1]\n    pos=True\n    for i in range(2,n):\n        if(arr[i]>=min):\n            pos=False\n            posf=i\n            break\n    if(pos):\n        print(\"-1\")\n    else:\n        print(\"1 2\", posf+1)\n","cleaned_code":"t=int(input())\nfor z in range(t):\n    n=int(input())\n    arr=list(map(int,input().split()))\n    min= arr[0] + arr[1]\n    pos=True\n    for i in range(2,n):\n        if(arr[i]>=min):\n            pos=False\n            posf=i\n            break\n    if(pos):\n        print(\"-1\")\n    else:\n        print(\"1 2\", posf+1)\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR BIN_OP VAR NUMBER VAR NUMBER ASSIGN VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER VAR IF VAR VAR VAR ASSIGN VAR NUMBER ASSIGN VAR VAR IF VAR EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING BIN_OP VAR NUMBER","self_reflection":"```xml\n<key_elements>\n    <task>Find three indices i, j, k such that 1 \u2264 i < j < k \u2264 n and it is impossible to construct a non-degenerate triangle with sides a_i, a_j, and a_k. If no such triple exists, report -1.<\/task>\n    <variables>\n        <variable name=\"t\" description=\"Number of test cases\" unit=\"count\" \/>\n        <variable name=\"n\" description=\"Length of the array a\" unit=\"count\" \/>\n        <variable name=\"a_i\" description=\"Elements of the array a\" unit=\"integer\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 t \u2264 1000<\/constraint>\n        <constraint>3 \u2264 n \u2264 5 * 10^4<\/constraint>\n        <constraint>1 \u2264 a_i \u2264 10^9<\/constraint>\n        <constraint>a_{i - 1} \u2264 a_i<\/constraint>\n        <constraint>The sum of n over all test cases does not exceed 10^5<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains one integer t (number of test cases).\n        Each test case consists of:\n        - The first line containing one integer n (length of the array a).\n        - The second line containing n integers a_1, a_2, ..., a_n (elements of the array a).\n    <\/input>\n    <output>\n        For each test case, print three indices i, j, k in ascending order if such a triple exists, otherwise print -1.\n    <\/output>\n    <formulas>\n        <formula>For a triangle with sides a_i, a_j, a_k to be non-degenerate, the following must hold: a_i + a_j > a_k<\/formula>\n    <\/formulas>\n    <logic_flow>\n        For each test case, find three indices i, j, k such that a_i + a_j \u2264 a_k. If such a triple exists, print the indices. If no such triple exists, print -1.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Pink Floyd are pulling a prank on Roger Waters. They know he doesn't like [walls](https:\/\/www.youtube.com\/watch?v=YR5ApYxkU-U), he wants to be able to walk freely, so they are blocking him from exiting his room which can be seen as a grid.\nRoger Waters has a square grid of size n\u00d7 n and he wants to traverse his grid from the upper left (1,1) corner to the lower right corner (n,n). Waters can move from a square to any other square adjacent by a side, as long as he is still in the grid. Also except for the cells (1,1) and (n,n) every cell has a value 0 or 1 in it.\nBefore starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose. The starting and finishing cells (1,1) and (n,n) are exempt from this rule, he may go through them regardless of picked digit. Because of this the cell (1,1) takes value the letter 'S' and the cell (n,n) takes value the letter 'F'.\nFor example, in the first example test case, he can go from (1, 1) to (n, n) by using the zeroes on this path: (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (3, 4), (4, 4)\nThe rest of the band (Pink Floyd) wants Waters to not be able to do his traversal, so while he is not looking they will invert at most two cells in the grid (from 0 to 1 or vice versa). They are afraid they will not be quick enough and asked for your help in choosing the cells.  Note that you cannot invert cells (1, 1) and (n, n).\nWe can show that there always exists a solution for the given constraints.\nAlso note that Waters will pick his digit of the traversal after the band has changed his grid, so he must not be able to reach (n,n) no matter what digit he picks.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases t (1 \u2264 t \u2264 50). Description of the test cases follows.\nThe first line of each test case contains one integers n (3 \u2264 n \u2264 200).\nThe following n lines of each test case contain the binary grid, square (1, 1) being colored in 'S' and square (n, n) being colored in 'F'.\nThe sum of values of n doesn't exceed 200.\nOutput\nFor each test case output on the first line an integer c (0 \u2264 c \u2264 2) \u2014 the number of inverted cells.\nIn i-th of the following c lines, print the coordinates of the i-th cell you inverted. You may not invert the same cell twice.  Note that you cannot invert cells (1, 1) and (n, n).\nExample\nInput\n3\n4\nS010\n0001\n1000\n111F\n3\nS10\n101\n01F\n5\nS0101\n00000\n01111\n11111\n0001F\nOutput\n1\n3 4\n2\n1 2\n2 1\n0\nNote\nFor the first test case, after inverting the cell, we get the following grid:\n    S010  \n    0001  \n    1001  \n    111F  \n    ","sample_inputs":"3\n4\nS010\n0001\n1000\n111F\n3\nS10\n101\n01F\n5\nS0101\n00000\n01111\n11111\n0001F\n","sample_outputs":"1\n3 4\n2\n1 2\n2 1\n0\n","cf_tags":["constructive algorithms","implementation"],"original_code":"l=[]\nfor _ in range(int(input())):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(input()))\n    if a[0][1]==a[1][0]:\n        if a[n-1][n-2]==a[n-2][n-1]:\n            if a[n-1][n-2]==a[0][1]:\n                l.append(\"2\")\n                l.append(\"1 2\")\n                l.append(\"2 1\")\n            else:\n                l.append(\"0\")\n        else:\n            if a[n-1][n-2]!=a[0][1]:\n                l.append(\"1\")\n                l.append(str(n-1)+\" \"+str(n))\n            else:\n                l.append(\"1\")\n                l.append(str(n)+\" \"+str(n-1))\n    else:\n        if a[n-1][n-2]==a[n-2][n-1]:\n            if a[n-1][n-2]!=a[0][1]:\n                l.append(\"1\")\n                l.append(\"2 1\")\n            else:\n                l.append(\"1\")\n                l.append(\"1 2\")\n        else:\n            if a[0][1]!=a[n-2][n-1]:\n                l.append(\"2\")\n                l.append(\"1 2\")\n                l.append(str(n-1)+\" \"+str(n))\n            else:\n                l.append(\"2\")\n                l.append(\"2 1\")\n                l.append(str(n - 1)+\" \"+ str(n))\nfor i in l:\n    print(i)","cleaned_code":"l=[]\nfor _ in range(int(input())):\n    n=int(input())\n    a=[]\n    for i in range(n):\n        a.append(list(input()))\n    if a[0][1]==a[1][0]:\n        if a[n-1][n-2]==a[n-2][n-1]:\n            if a[n-1][n-2]==a[0][1]:\n                l.append(\"2\")\n                l.append(\"1 2\")\n                l.append(\"2 1\")\n            else:\n                l.append(\"0\")\n        else:\n            if a[n-1][n-2]!=a[0][1]:\n                l.append(\"1\")\n                l.append(str(n-1)+\" \"+str(n))\n            else:\n                l.append(\"1\")\n                l.append(str(n)+\" \"+str(n-1))\n    else:\n        if a[n-1][n-2]==a[n-2][n-1]:\n            if a[n-1][n-2]!=a[0][1]:\n                l.append(\"1\")\n                l.append(\"2 1\")\n            else:\n                l.append(\"1\")\n                l.append(\"1 2\")\n        else:\n            if a[0][1]!=a[n-2][n-1]:\n                l.append(\"2\")\n                l.append(\"1 2\")\n                l.append(str(n-1)+\" \"+str(n))\n            else:\n                l.append(\"2\")\n                l.append(\"2 1\")\n                l.append(str(n - 1)+\" \"+ str(n))\nfor i in l:\n    print(i)","normalized_code":"ASSIGN VAR LIST FOR VAR FUNC_CALL VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR FUNC_CALL VAR FUNC_CALL VAR IF VAR NUMBER NUMBER VAR NUMBER NUMBER IF VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER IF VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR NUMBER NUMBER EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING IF VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR NUMBER NUMBER EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR BIN_OP BIN_OP FUNC_CALL VAR BIN_OP VAR NUMBER STRING FUNC_CALL VAR VAR EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR BIN_OP BIN_OP FUNC_CALL VAR VAR STRING FUNC_CALL VAR BIN_OP VAR NUMBER IF VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER IF VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER VAR NUMBER NUMBER EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING IF VAR NUMBER NUMBER VAR BIN_OP VAR NUMBER BIN_OP VAR NUMBER EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR BIN_OP BIN_OP FUNC_CALL VAR BIN_OP VAR NUMBER STRING FUNC_CALL VAR VAR EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR STRING EXPR FUNC_CALL VAR BIN_OP BIN_OP FUNC_CALL VAR BIN_OP VAR NUMBER STRING FUNC_CALL VAR VAR FOR VAR VAR EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the minimum number of cells to invert (0 to 2) in a grid so that Roger Waters cannot traverse from the upper left corner (1,1) to the lower right corner (n,n) regardless of the digit he picks.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Size of the square grid\" unit=\"integer\" range=\"3 \u2264 n \u2264 200\"\/>\n        <variable name=\"grid\" description=\"n\u00d7n grid where each cell contains either 'S', 'F', 0, or 1\" unit=\"grid\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>Cells (1,1) and (n,n) are 'S' and 'F' respectively and cannot be inverted.<\/constraint>\n        <constraint>The sum of values of n doesn't exceed 200.<\/constraint>\n        <constraint>Waters can only move to cells with the same value as the digit he picks, except for the starting and ending cells.<\/constraint>\n    <\/constraints>\n    <input>\n        <input_line>Number of test cases t (1 \u2264 t \u2264 50)<\/input_line>\n        <input_line>For each test case: n (3 \u2264 n \u2264 200)<\/input_line>\n        <input_line>n lines of the binary grid, with 'S' at (1,1) and 'F' at (n,n)<\/input_line>\n    <\/input>\n    <output>\n        <output_line>For each test case, output an integer c (0 \u2264 c \u2264 2) \u2014 the number of inverted cells.<\/output_line>\n        <output_line>For each inverted cell, output its coordinates (i-th line: i-th cell coordinates)<\/output_line>\n    <\/output>\n    <formulas\/>\n    <logic_flow>\n        Determine the minimum number of cells to invert so that there is no path from (1,1) to (n,n) for either digit Waters picks.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer. However, Vasilisa the Wise does not know what the box's secret is, since she cannot open it again. She hopes that you will help her one more time with that.\nThe box's lock looks as follows: it contains 4 identical deepenings for gems as a 2 \u00d7 2 square, and some integer numbers are written at the lock's edge near the deepenings. The example of a lock is given on the picture below.\n<image>\nThe box is accompanied with 9 gems. Their shapes match the deepenings' shapes and each gem contains one number from 1 to 9 (each number is written on exactly one gem). The box will only open after it is decorated with gems correctly: that is, each deepening in the lock should be filled with exactly one gem. Also, the sums of numbers in the square's rows, columns and two diagonals of the square should match the numbers written at the lock's edge. For example, the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below.\n<image>\nNow Vasilisa the Wise wants to define, given the numbers on the box's lock, which gems she should put in the deepenings to open the box. Help Vasilisa to solve this challenging task.\nInput\nThe input contains numbers written on the edges of the lock of the box. The first line contains space-separated integers r1 and r2 that define the required sums of numbers in the rows of the square. The second line contains space-separated integers c1 and c2 that define the required sums of numbers in the columns of the square. The third line contains space-separated integers d1 and d2 that define the required sums of numbers on the main and on the side diagonals of the square (1 \u2264 r1, r2, c1, c2, d1, d2 \u2264 20). Correspondence between the above 6 variables and places where they are written is shown on the picture below. For more clarifications please look at the second sample test that demonstrates the example given in the problem statement.\n<image>\nOutput\nPrint the scheme of decorating the box with stones: two lines containing two space-separated integers from 1 to 9. The numbers should be pairwise different. If there is no solution for the given lock, then print the single number \"-1\" (without the quotes).\nIf there are several solutions, output any.\nExamples\nInput\n3 7\n4 6\n5 5\nOutput\n1 2\n3 4\nInput\n11 10\n13 8\n5 16\nOutput\n4 7\n9 1\nInput\n1 2\n3 4\n5 6\nOutput\n-1\nInput\n10 10\n10 10\n10 10\nOutput\n-1\nNote\nPay attention to the last test from the statement: it is impossible to open the box because for that Vasilisa the Wise would need 4 identical gems containing number \"5\". However, Vasilisa only has one gem with each number from 1 to 9.","sample_inputs":"1 2\n3 4\n5 6\n11 10\n13 8\n5 16\n3 7\n4 6\n5 5\n10 10\n10 10\n10 10\n","sample_outputs":"-1\n4 7\n9 1\n1 2\n3 4\n-1\n","cf_tags":["brute force","math"],"original_code":"inn = list(map(int, input().split(\" \")))\nr1 = inn[0]\nr2 = inn[1]\ninn = list(map(int, input().split(\" \")))\nc1 = inn[0]\nc2 = inn[1]\ninn = list(map(int, input().split(\" \")))\nd1 = inn[0]\nd2 = inn[1]\n\nx = int((d1+c1-r2)\/2)\ny = int(((2*r1)-d1-c1+r2)\/2)\na = int(((2*c1)-d1-c1+r2)\/2)\nb = int((r2-(2*c1)+d1+c1)\/2)\nif x == y or x == a or x == b or y == a or y == b or a == b or x < 1 or x > 9 or y < 1 or y > 9 or a < 1 or a > 9 or b < 1 or b > 9:\n    print(-1)\nelse:\n    print(x, y)\n    print(a, b)","cleaned_code":"inn = list(map(int, input().split(\" \")))\nr1 = inn[0]\nr2 = inn[1]\ninn = list(map(int, input().split(\" \")))\nc1 = inn[0]\nc2 = inn[1]\ninn = list(map(int, input().split(\" \")))\nd1 = inn[0]\nd2 = inn[1]\nx = int((d1+c1-r2)\/2)\ny = int(((2*r1)-d1-c1+r2)\/2)\na = int(((2*c1)-d1-c1+r2)\/2)\nb = int((r2-(2*c1)+d1+c1)\/2)\nif x == y or x == a or x == b or y == a or y == b or a == b or x < 1 or x > 9 or y < 1 or y > 9 or a < 1 or a > 9 or b < 1 or b > 9:\n    print(-1)\nelse:\n    print(x, y)\n    print(a, b)","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR STRING ASSIGN VAR VAR NUMBER ASSIGN VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR STRING ASSIGN VAR VAR NUMBER ASSIGN VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR STRING ASSIGN VAR VAR NUMBER ASSIGN VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR BIN_OP BIN_OP BIN_OP VAR VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR BIN_OP BIN_OP BIN_OP BIN_OP BIN_OP NUMBER VAR VAR VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR BIN_OP BIN_OP BIN_OP BIN_OP BIN_OP NUMBER VAR VAR VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR BIN_OP BIN_OP BIN_OP BIN_OP VAR BIN_OP NUMBER VAR VAR VAR NUMBER IF VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR NUMBER VAR NUMBER VAR NUMBER VAR NUMBER VAR NUMBER VAR NUMBER VAR NUMBER VAR NUMBER EXPR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Define the correct arrangement of gems to open the box based on the sums provided for rows, columns, and diagonals.<\/task>\n    <variables>\n        <variable name=\"r1\" description=\"Sum of numbers in the first row\" unit=\"integer\"\/>\n        <variable name=\"r2\" description=\"Sum of numbers in the second row\" unit=\"integer\"\/>\n        <variable name=\"c1\" description=\"Sum of numbers in the first column\" unit=\"integer\"\/>\n        <variable name=\"c2\" description=\"Sum of numbers in the second column\" unit=\"integer\"\/>\n        <variable name=\"d1\" description=\"Sum of numbers on the main diagonal\" unit=\"integer\"\/>\n        <variable name=\"d2\" description=\"Sum of numbers on the side diagonal\" unit=\"integer\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 r1, r2, c1, c2, d1, d2 \u2264 20<\/constraint>\n        <constraint>Each number from 1 to 9 is used exactly once.<\/constraint>\n    <\/constraints>\n    <input>\n        The input contains six space-separated integers on three lines: r1, r2, c1, c2, d1, d2.\n    <\/input>\n    <output>\n        Print two lines containing two space-separated integers each, representing the arrangement of gems. If no solution exists, print \"-1\".\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement. -->\n    <\/formulas>\n    <logic_flow>\n        Determine if there exists a 2x2 arrangement of the numbers 1 through 9 such that the sums of the rows, columns, and diagonals match the given values.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You may know that Euclid was a mathematician. Well, as it turns out, Morpheus knew it too. So when he wanted to play a mean trick on Euclid, he sent him an appropriate nightmare. \nIn his bad dream Euclid has a set S of n m-dimensional vectors over the Z_2 field and can perform vector addition on them. In other words he has vectors with m coordinates, each one equal either 0 or 1. Vector addition is defined as follows: let u+v = w, then w_i = (u_i + v_i) mod 2. \nEuclid can sum any subset of S and archive another m-dimensional vector over Z_2. In particular, he can sum together an empty subset; in such a case, the resulting vector has all coordinates equal 0.\nLet T be the set of all the vectors that can be written as a sum of some vectors from S. Now Euclid wonders the size of T and whether he can use only a subset S' of S to obtain all the vectors from T. As it is usually the case in such scenarios, he will not wake up until he figures this out. So far, things are looking rather grim for the philosopher. But there is hope, as he noticed that all vectors in S have at most 2 coordinates equal 1. \nHelp Euclid and calculate |T|, the number of m-dimensional vectors over Z_2 that can be written as a sum of some vectors from S. As it can be quite large, calculate it modulo 10^9+7. You should also find S', the smallest such subset of S, that all vectors in T can be written as a sum of vectors from S'. In case there are multiple such sets with a minimal number of elements, output the lexicographically smallest one with respect to the order in which their elements are given in the input. \nConsider sets A and B such that |A| = |B|. Let a_1, a_2, ... a_{|A|} and b_1, b_2, ... b_{|B|} be increasing arrays of indices elements of A and B correspondingly. A is lexicographically smaller than B iff there exists such i that a_j = b_j for all j < i and a_i < b_i.\nInput\nIn the first line of input, there are two integers n, m (1 \u2264 n, m \u2264 5 \u22c5 10^5) denoting the number of vectors in S and the number of dimensions. \nNext n lines contain the description of the vectors in S. In each of them there is an integer k (1 \u2264 k \u2264 2) and then follow k distinct integers x_1, ... x_k (1 \u2264 x_i \u2264 m). This encodes an m-dimensional vector having 1s on coordinates x_1, ... x_k and 0s on the rest of them.\nAmong the n vectors, no two are the same.\nOutput\nIn the first line, output two integers: remainder modulo 10^9+7 of |T| and |S'|. In the second line, output |S'| numbers, indices of the elements of S' in ascending order. The elements of S are numbered from 1 in the order they are given in the input.\nExamples\nInput\n3 2\n1 1\n1 2\n2 2 1\nOutput\n4 2\n1 2 \nInput\n2 3\n2 1 3\n2 1 2\nOutput\n4 2\n1 2 \nInput\n3 5\n2 1 2\n1 3\n1 4\nOutput\n8 3\n1 2 3 \nNote\nIn the first example we are given three vectors: \n  * 10 \n  * 01 \n  * 11 \nIt turns out that we can represent all vectors from our 2-dimensional space using these vectors: \n  * 00 is a sum of the empty subset of above vectors; \n  * 01 = 11 + 10, is a sum of the first and third vector; \n  * 10 = 10, is just the first vector; \n  * 11 = 10 + 01, is a sum of the first and the second vector. \nHence, T = \\{00, 01, 10, 11\\}. We can choose any two of the three vectors from S and still be able to obtain all the vectors in T. In such a case, we choose the two vectors which appear first in the input. Since we cannot obtain all vectors in T using only a single vector from S, |S'| = 2 and S' = \\{10, 01\\} (indices 1 and 2), as set \\{1, 2 \\} is lexicographically the smallest. We can represent all vectors from T, using only vectors from S', as shown below: \n  * 00 is a sum of the empty subset; \n  * 01 = 01 is just the second vector; \n  * 10 = 10 is just the first vector; \n  * 11 = 10 + 01 is a sum of the first and the second vector. ","sample_inputs":"3 2\n1 1\n1 2\n2 2 1\n3 5\n2 1 2\n1 3\n1 4\n2 3\n2 1 3\n2 1 2\n","sample_outputs":"\n4 2\n1 2 \n\n8 3\n1 2 3 \n\n4 2\n1 2 \n","cf_tags":["bitmasks","dfs and similar","dsu","graphs","greedy","math","sortings"],"original_code":"import sys\ninput = sys.stdin.buffer.readline\n\ndef _find(s, u):\n    p = []\n    while s[u] != u:\n        p.append(u)\n        u = s[u]\n    for v in p: s[v] = u\n    return u\n\ndef _union(s, u, v):\n    su, sv = _find(s, u), _find(s, v)\n    if su != sv: s[su] = sv\n    return su != sv\n\nn, m = map(int, input().split())\ns, solo = list(range(m+1)), [0]*(m+1)\nres, pos = [], set()\nfor i in range(n):\n    p = list(map(int, input().split()))\n    if p[0] == 1:\n        pos.add(p[1])\n        p1 = _find(s, p[1])\n        if not solo[p1]:\n            res.append(i+1)\n            solo[p1] = 1\n    else:\n        pos.add(p[1])\n        pos.add(p[2])\n        p1, p2 = _find(s, p[1]), _find(s, p[2])\n        if not (p1 == p2 or (solo[p1] and solo[p2])):\n            _union(s, p1, p2)\n            res.append(i+1)\n            if solo[p1] or solo[p2]:\n                solo[_find(s, p1)] = 1\n\ncc = 0\nfor u in pos:\n    su = _find(s, u)\n    cc += 1\n    if not solo[su] and su == u:\n        cc -= 1\n\nprint(pow(2, cc, 10**9+7), len(res))\nprint(*res)\n        \n\n\n","cleaned_code":"import sys\ninput = sys.stdin.buffer.readline\ndef _find(s, u):\n    p = []\n    while s[u] != u:\n        p.append(u)\n        u = s[u]\n    for v in p: s[v] = u\n    return u\ndef _union(s, u, v):\n    su, sv = _find(s, u), _find(s, v)\n    if su != sv: s[su] = sv\n    return su != sv\nn, m = map(int, input().split())\ns, solo = list(range(m+1)), [0]*(m+1)\nres, pos = [], set()\nfor i in range(n):\n    p = list(map(int, input().split()))\n    if p[0] == 1:\n        pos.add(p[1])\n        p1 = _find(s, p[1])\n        if not solo[p1]:\n            res.append(i+1)\n            solo[p1] = 1\n    else:\n        pos.add(p[1])\n        pos.add(p[2])\n        p1, p2 = _find(s, p[1]), _find(s, p[2])\n        if not (p1 == p2 or (solo[p1] and solo[p2])):\n            _union(s, p1, p2)\n            res.append(i+1)\n            if solo[p1] or solo[p2]:\n                solo[_find(s, p1)] = 1\ncc = 0\nfor u in pos:\n    su = _find(s, u)\n    cc += 1\n    if not solo[su] and su == u:\n        cc -= 1\nprint(pow(2, cc, 10**9+7), len(res))\nprint(*res)\n","normalized_code":"IMPORT ASSIGN VAR VAR FUNC_DEF ASSIGN VAR LIST WHILE VAR VAR VAR EXPR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR FOR VAR VAR ASSIGN VAR VAR VAR RETURN VAR FUNC_DEF ASSIGN VAR VAR FUNC_CALL VAR VAR VAR FUNC_CALL VAR VAR VAR IF VAR VAR ASSIGN VAR VAR VAR RETURN VAR VAR ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR VAR FUNC_CALL VAR FUNC_CALL VAR BIN_OP VAR NUMBER BIN_OP LIST NUMBER BIN_OP VAR NUMBER ASSIGN VAR VAR LIST FUNC_CALL VAR FOR VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR IF VAR NUMBER NUMBER EXPR FUNC_CALL VAR VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR VAR NUMBER IF VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR VAR NUMBER EXPR FUNC_CALL VAR VAR NUMBER EXPR FUNC_CALL VAR VAR NUMBER ASSIGN VAR VAR FUNC_CALL VAR VAR VAR NUMBER FUNC_CALL VAR VAR VAR NUMBER IF VAR VAR VAR VAR VAR VAR EXPR FUNC_CALL VAR VAR VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER IF VAR VAR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR NUMBER ASSIGN VAR NUMBER FOR VAR VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR NUMBER IF VAR VAR VAR VAR VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR NUMBER VAR BIN_OP BIN_OP NUMBER NUMBER NUMBER FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Calculate the size of the set T, which contains all m-dimensional vectors over Z_2 that can be written as a sum of some vectors from the set S, and find the smallest subset S' of S that can generate all vectors in T. Output the size of T modulo 10^9+7 and the indices of the elements of S' in ascending order.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of vectors in set S\" unit=\"count\"\/>\n        <variable name=\"m\" description=\"Number of dimensions of each vector\" unit=\"count\"\/>\n        <variable name=\"S\" description=\"Set of n m-dimensional vectors over Z_2\" unit=\"set of vectors\"\/>\n        <variable name=\"T\" description=\"Set of all m-dimensional vectors over Z_2 that can be written as a sum of some vectors from S\" unit=\"set of vectors\"\/>\n        <variable name=\"S'\" description=\"Smallest subset of S that can generate all vectors in T\" unit=\"subset of S\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n, m \u2264 5 \u22c5 10^5<\/constraint>\n        <constraint>Each vector in S has at most 2 coordinates equal to 1<\/constraint>\n        <constraint>No two vectors in S are the same<\/constraint>\n    <\/constraints>\n    <input>\n        <input_line>Two integers n and m (1 \u2264 n, m \u2264 5 \u22c5 10^5)<\/input_line>\n        <input_line>n lines, each containing an integer k (1 \u2264 k \u2264 2) and then k distinct integers x_1, ... x_k (1 \u2264 x_i \u2264 m)<\/input_line>\n    <\/input>\n    <output>\n        <output_line>Two integers: remainder modulo 10^9+7 of |T| and |S'|<\/output_line>\n        <output_line>|S'| numbers, indices of the elements of S' in ascending order<\/output_line>\n    <\/output>\n    <formulas>\n        <formula>Vector addition: w_i = (u_i + v_i) mod 2<\/formula>\n    <\/formulas>\n    <logic_flow>\n        Calculate the set T by summing all possible subsets of vectors from S.\n        Find the smallest subset S' of S that can generate all vectors in T.\n        Output the size of T modulo 10^9+7 and the indices of the elements of S' in ascending order.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Polycarp was dismantling his attic and found an old floppy drive on it. A round disc was inserted into the drive with n integers written on it.\nPolycarp wrote the numbers from the disk into the a array. It turned out that the drive works according to the following algorithm: \n  * the drive takes one positive number x as input and puts a pointer to the first element of the a array; \n  * after that, the drive starts rotating the disk, every second moving the pointer to the next element, counting the sum of all the elements that have been under the pointer. Since the disk is round, in the a array, the last element is again followed by the first one; \n  * as soon as the sum is at least x, the drive will shut down. \nPolycarp wants to learn more about the operation of the drive, but he has absolutely no free time. So he asked you m questions. To answer the i-th of them, you need to find how many seconds the drive will work if you give it x_i as input. Please note that in some cases the drive can work infinitely.\nFor example, if n=3, m=3, a=[1, -3, 4] and x=[1, 5, 2], then the answers to the questions are as follows: \n  * the answer to the first query is 0 because the drive initially points to the first item and the initial sum is 1. \n  * the answer to the second query is 6, the drive will spin the disk completely twice and the amount becomes 1+(-3)+4+1+(-3)+4+1=5. \n  * the answer to the third query is 2, the amount is 1+(-3)+4=2. \nInput\nThe first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case consists of two positive integers n, m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the number of numbers on the disk and the number of asked questions.\nThe second line of each test case contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\nThe third line of each test case contains m positive integers x_1, x_2, \u2026, x_m (1 \u2264 x \u2264 10^9).\nIt is guaranteed that the sums of n and m over all test cases do not exceed 2 \u22c5 10^5. \nOutput\nPrint m numbers on a separate line for each test case. The i-th number is: \n  * -1 if the drive will run infinitely; \n  * the number of seconds the drive will run, otherwise. \nExample\nInput\n3\n3 3\n1 -3 4\n1 5 2\n2 2\n-2 0\n1 2\n2 2\n0 1\n1 2\nOutput\n0 6 2 \n-1 -1 \n1 3 ","sample_inputs":"3\n3 3\n1 -3 4\n1 5 2\n2 2\n-2 0\n1 2\n2 2\n0 1\n1 2\n","sample_outputs":"\n0 6 2 \n-1 -1 \n1 3 \n","cf_tags":["binary search","data structures","math"],"original_code":"\ndef findIndexGE(prefixSumsMax,startSum,query):\n    n=len(prefixSumsMax)\n    b=n\n    i=-1\n    while b>0:\n        while i+b<n and startSum+prefixSumsMax[i+b]<query:\n            i+=b\n        b\/\/=2\n    i+=1\n    return i\n\ndef main():\n    \n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        arr=readIntArr() #numbers of disk\n        queries=readIntArr()\n        \n        prefixSums=arr.copy()\n        for i in range(1,n):\n            prefixSums[i]+=prefixSums[i-1]\n        \n        maxP=max(prefixSums)\n        \n        prefixSumsMax=prefixSums.copy()\n        for i in range(1,n):\n            prefixSumsMax[i]=max(prefixSumsMax[i-1],prefixSums[i])\n        \n        ans=[]\n        for q in queries:\n            if prefixSums[n-1]<=0:\n                if q>maxP: #drive will run indefinitely\n                    ans.append(-1)\n                else:\n                    ans.append(findIndexGE(prefixSumsMax,0,q))\n            else:\n                #find number of cycles\n                nCycles=-1\n                b=10**9\n                while b>0:\n                    while prefixSums[n-1]*(nCycles+b)+maxP<q:\n                        nCycles+=b\n                    b\/\/=2\n                nCycles+=1\n                \n                startSum=prefixSums[n-1]*nCycles\n                lastCycleIdx=findIndexGE(prefixSumsMax,startSum,q)\n                ans.append(nCycles*n+lastCycleIdx)\n        allans.append(ans)\n    multiLineArrayOfArraysPrint(allans)\n    \n    return\n    \n#import sys\n#input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\nimport sys\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\n \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\n \ndef readIntArr():\n    return [int(x) for x in input().split()]\n \ninf=float('inf')\nMOD=10**9+7\n \nmain()","cleaned_code":"\ndef findIndexGE(prefixSumsMax,startSum,query):\n    n=len(prefixSumsMax)\n    b=n\n    i=-1\n    while b>0:\n        while i+b<n and startSum+prefixSumsMax[i+b]<query:\n            i+=b\n        b\/\/=2\n    i+=1\n    return i\ndef main():\n    t=int(input())\n    allans=[]\n    for _ in range(t):\n        n,m=readIntArr()\n        arr=readIntArr() #numbers of disk\n        queries=readIntArr()\n        prefixSums=arr.copy()\n        for i in range(1,n):\n            prefixSums[i]+=prefixSums[i-1]\n        maxP=max(prefixSums)\n        prefixSumsMax=prefixSums.copy()\n        for i in range(1,n):\n            prefixSumsMax[i]=max(prefixSumsMax[i-1],prefixSums[i])\n        ans=[]\n        for q in queries:\n            if prefixSums[n-1]<=0:\n                if q>maxP: #drive will run indefinitely\n                    ans.append(-1)\n                else:\n                    ans.append(findIndexGE(prefixSumsMax,0,q))\n            else:\n                #find number of cycles\n                nCycles=-1\n                b=10**9\n                while b>0:\n                    while prefixSums[n-1]*(nCycles+b)+maxP<q:\n                        nCycles+=b\n                    b\/\/=2\n                nCycles+=1\n                startSum=prefixSums[n-1]*nCycles\n                lastCycleIdx=findIndexGE(prefixSumsMax,startSum,q)\n                ans.append(nCycles*n+lastCycleIdx)\n        allans.append(ans)\n    multiLineArrayOfArraysPrint(allans)\n    return\nimport sys\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") \ndef oneLineArrayPrint(arr):\n    print(' '.join([str(x) for x in arr]))\ndef multiLineArrayPrint(arr):\n    print('\\n'.join([str(x) for x in arr]))\ndef multiLineArrayOfArraysPrint(arr):\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\ndef readIntArr():\n    return [int(x) for x in input().split()]\ninf=float('inf')\nMOD=10**9+7\nmain()","normalized_code":"FUNC_DEF ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR VAR ASSIGN VAR NUMBER WHILE VAR NUMBER WHILE BIN_OP VAR VAR VAR BIN_OP VAR VAR BIN_OP VAR VAR VAR VAR VAR VAR NUMBER VAR NUMBER RETURN VAR FUNC_DEF ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR NUMBER VAR VAR VAR VAR BIN_OP VAR NUMBER ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR NUMBER VAR ASSIGN VAR VAR FUNC_CALL VAR VAR BIN_OP VAR NUMBER VAR VAR ASSIGN VAR LIST FOR VAR VAR IF VAR BIN_OP VAR NUMBER NUMBER IF VAR VAR EXPR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR VAR NUMBER VAR ASSIGN VAR NUMBER ASSIGN VAR BIN_OP NUMBER NUMBER WHILE VAR NUMBER WHILE BIN_OP BIN_OP VAR BIN_OP VAR NUMBER BIN_OP VAR VAR VAR VAR VAR VAR VAR NUMBER VAR NUMBER ASSIGN VAR BIN_OP VAR BIN_OP VAR NUMBER VAR ASSIGN VAR FUNC_CALL VAR VAR VAR VAR EXPR FUNC_CALL VAR BIN_OP BIN_OP VAR VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR RETURN IMPORT ASSIGN VAR FUNC_CALL FUNC_CALL VAR STRING FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR FUNC_DEF EXPR FUNC_CALL VAR FUNC_CALL STRING FUNC_CALL STRING FUNC_CALL VAR VAR VAR VAR VAR VAR FUNC_DEF RETURN FUNC_CALL VAR VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR STRING ASSIGN VAR BIN_OP BIN_OP NUMBER NUMBER NUMBER EXPR FUNC_CALL VAR","self_reflection":"```xml\n<key_elements>\n    <task>For each test case, determine how many seconds the drive will work for given inputs x_i, or if it will run infinitely.<\/task>\n    <variables>\n        <variable name=\"t\" description=\"Number of test cases\" unit=\"count\" \/>\n        <variable name=\"n\" description=\"Number of numbers on the disk\" unit=\"count\" \/>\n        <variable name=\"m\" description=\"Number of asked questions\" unit=\"count\" \/>\n        <variable name=\"a\" description=\"Array of integers on the disk\" unit=\"integer\" \/>\n        <variable name=\"x\" description=\"Array of integers for the drive's input\" unit=\"integer\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 t \u2264 10^4<\/constraint>\n        <constraint>1 \u2264 n, m \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>-10^9 \u2264 a_i \u2264 10^9<\/constraint>\n        <constraint>1 \u2264 x \u2264 10^9<\/constraint>\n        <constraint>The sums of n and m over all test cases do not exceed 2 \u22c5 10^5<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains one integer t (1 \u2264 t \u2264 10^4) \u2014 the number of test cases. Then t test cases follow.\n        The first line of each test case consists of two positive integers n, m (1 \u2264 n, m \u2264 2 \u22c5 10^5) \u2014 the number of numbers on the disk and the number of asked questions.\n        The second line of each test case contains n integers a_1, a_2, \u2026, a_n (-10^9 \u2264 a_i \u2264 10^9).\n        The third line of each test case contains m positive integers x_1, x_2, \u2026, x_m (1 \u2264 x \u2264 10^9).\n    <\/input>\n    <output>\n        Print m numbers on a separate line for each test case. The i-th number is: \n        * -1 if the drive will run infinitely; \n        * the number of seconds the drive will run, otherwise.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        For each test case, simulate the drive's operation for each input x_i to determine the number of seconds the drive will run or if it will run infinitely.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given an integer n. You have to apply m operations to it.\nIn a single operation, you must replace every digit d of the number with the decimal representation of integer d + 1. For example, 1912 becomes 21023 after applying the operation once.\nYou have to find the length of n after applying m operations. Since the answer can be very large, print it modulo 10^9+7.\nInput\nThe first line contains a single integer t (1 \u2264 t \u2264 2 \u22c5 10^5) \u2014 the number of test cases.\nThe only line of each test case contains two integers n (1 \u2264 n \u2264 10^9) and m (1 \u2264 m \u2264 2 \u22c5 10^5) \u2014 the initial number and the number of operations. \nOutput\nFor each test case output the length of the resulting number modulo 10^9+7.\nExample\nInput\n5\n1912 1\n5 6\n999 1\n88 2\n12 100\nOutput\n5\n2\n6\n4\n2115\nNote\nFor the first test, 1912 becomes 21023 after 1 operation which is of length 5.\nFor the second test, 5 becomes 21 after 6 operations which is of length 2.\nFor the third test, 999 becomes 101010 after 1 operation which is of length 6.\nFor the fourth test, 88 becomes 1010 after 2 operations which is of length 4.","sample_inputs":"5\n1912 1\n5 6\n999 1\n88 2\n12 100\n","sample_outputs":"\n5\n2\n6\n4\n2115\n","cf_tags":["dp","matrices"],"original_code":"from os import path\nimport sys,time\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import defaultdict ,Counter , OrderedDict , deque\nfrom heapq import heapify , heappush , heappop\nfrom bisect import *\n# from functools import reduce\nfrom operator import mul\nfrom itertools import permutations\nmaxx, mod  = float('inf') , int(1e9 + 7)\nlocalsys ,start_time = 0 , time.time()\nif (path.exists('input.txt')):\n    localsys = 1;sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\n#left shift --- num*(2**k) --(k - shift)\ninput = sys.stdin.readline\nN = int(2e5 + 10)\ndp =[1]*N\nfor i in range(10 , N):\n    dp[i] = (dp[i-9] + dp[i-10])%mod\nfor _ in range(int(input())):\n    n , m = map(int , input().split()) ; ans =0\n    while n :\n        i = n%10 ; n\/\/=10\n        ans = (ans + dp[i + m])%mod\n    print(ans)\n\n\n\n    \n\n\n\n\n\n\nif localsys:\n    print(\"\\n\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","cleaned_code":"from os import path\nimport sys,time\nfrom math import ceil, floor,gcd,log,log2 ,factorial\nfrom collections import defaultdict ,Counter , OrderedDict , deque\nfrom heapq import heapify , heappush , heappop\nfrom bisect import *\nfrom operator import mul\nfrom itertools import permutations\nmaxx, mod  = float('inf') , int(1e9 + 7)\nlocalsys ,start_time = 0 , time.time()\nif (path.exists('input.txt')):\n    localsys = 1;sys.stdin=open('input.txt','r');sys.stdout=open('output.txt','w');\ninput = sys.stdin.readline\nN = int(2e5 + 10)\ndp =[1]*N\nfor i in range(10 , N):\n    dp[i] = (dp[i-9] + dp[i-10])%mod\nfor _ in range(int(input())):\n    n , m = map(int , input().split()) ; ans =0\n    while n :\n        i = n%10 ; n\/\/=10\n        ans = (ans + dp[i + m])%mod\n    print(ans)\nif localsys:\n    print(\"\\n\\n\\nTime Elased :\",time.time() - start_time,\"seconds\")","normalized_code":"IMPORT ASSIGN VAR VAR FUNC_CALL VAR STRING FUNC_CALL VAR BIN_OP NUMBER NUMBER ASSIGN VAR VAR NUMBER FUNC_CALL VAR IF FUNC_CALL VAR STRING ASSIGN VAR NUMBER ASSIGN VAR FUNC_CALL VAR STRING STRING ASSIGN VAR FUNC_CALL VAR STRING STRING ASSIGN VAR VAR ASSIGN VAR FUNC_CALL VAR BIN_OP NUMBER NUMBER ASSIGN VAR BIN_OP LIST NUMBER VAR FOR VAR FUNC_CALL VAR NUMBER VAR ASSIGN VAR VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER VAR BIN_OP VAR NUMBER VAR FOR VAR FUNC_CALL VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR NUMBER WHILE VAR ASSIGN VAR BIN_OP VAR NUMBER VAR NUMBER ASSIGN VAR BIN_OP BIN_OP VAR VAR BIN_OP VAR VAR VAR EXPR FUNC_CALL VAR VAR IF VAR EXPR FUNC_CALL VAR STRING BIN_OP FUNC_CALL VAR VAR STRING","self_reflection":"```xml\n<key_elements>\n    <task>Find the length of a number after applying a series of operations<\/task>\n    <variables>\n        <variable name=\"t\" description=\"Number of test cases\" unit=\"count\"\/>\n        <variable name=\"n\" description=\"Initial number\" unit=\"integer\"\/>\n        <variable name=\"m\" description=\"Number of operations\" unit=\"count\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 t \u2264 2 \u22c5 10^5<\/constraint>\n        <constraint>1 \u2264 n \u2264 10^9<\/constraint>\n        <constraint>1 \u2264 m \u2264 2 \u22c5 10^5<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains a single integer t (number of test cases).\n        Each of the next t lines contains two integers n and m.\n    <\/input>\n    <output>\n        For each test case, output the length of the resulting number modulo 10^9+7.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        For each test case, apply m operations to the number n by incrementing each digit by 1. Then, find the length of the resulting number and output it modulo 10^9+7.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"This is the easy version of the problem. The only difference is that in this version q = 1. You can make hacks only if both versions of the problem are solved.\nThere is a process that takes place on arrays a and b of length n and length n-1 respectively. \nThe process is an infinite sequence of operations. Each operation is as follows: \n  * First, choose a random integer i (1 \u2264 i \u2264 n-1). \n  * Then, simultaneously set a_i = min\\left(a_i, \\frac{a_i+a_{i+1}-b_i}{2}\\right) and a_{i+1} = max\\left(a_{i+1}, \\frac{a_i+a_{i+1}+b_i}{2}\\right) without any rounding (so values may become non-integer). \nSee notes for an example of an operation.\nIt can be proven that array a converges, i. e. for each i there exists a limit a_i converges to. Let function F(a, b) return the value a_1 converges to after a process on a and b.\nYou are given array b, but not array a. However, you are given a third array c. Array a is good if it contains only integers and satisfies 0 \u2264 a_i \u2264 c_i for 1 \u2264 i \u2264 n.\nYour task is to count the number of good arrays a where F(a, b) \u2265 x for q values of x. Since the number of arrays can be very large, print it modulo 10^9+7.\nInput\nThe first line contains a single integer n (2 \u2264 n \u2264 100).\nThe second line contains n integers c_1, c_2 \u2026, c_n (0 \u2264 c_i \u2264 100).\nThe third line contains n-1 integers b_1, b_2, \u2026, b_{n-1} (0 \u2264 b_i \u2264 100).\nThe fourth line contains a single integer q (q=1).\nThe fifth line contains q space separated integers x_1, x_2, \u2026, x_q (-10^5 \u2264 x_i \u2264 10^5).\nOutput\nOutput q integers, where the i-th integer is the answer to the i-th query, i. e. the number of good arrays a where F(a, b) \u2265 x_i modulo 10^9+7.\nExample\nInput\n3\n2 3 4\n2 1\n1\n-1\nOutput\n56\nNote\nThe following explanation assumes b = [2, 1] and c=[2, 3, 4] (as in the sample).\nExamples of arrays a that are not good: \n  * a = [3, 2, 3] is not good because a_1 > c_1; \n  * a = [0, -1, 3] is not good because a_2 < 0. \nOne possible good array a is [0, 2, 4]. We can show that no operation has any effect on this array, so F(a, b) = a_1 = 0.\nAnother possible good array a is [0, 1, 4]. In a single operation with i = 1, we set a_1 = min((0+1-2)\/(2), 0) and a_2 = max((0+1+2)\/(2), 1). So, after a single operation with i = 1, a becomes equal to [-1\/2, 3\/2, 4]. We can show that no operation has any effect on this array, so F(a, b) = -1\/2.","sample_inputs":"3\n2 3 4\n2 1\n1\n-1\n","sample_outputs":"56\n","cf_tags":["dp","math"],"original_code":"def putin():\n    return map(int, input().split())\n\n\ndef sol():\n    n = int(input())\n    C = list(putin())\n    B = list(putin())\n    q = int(input())\n    x = int(input())\n    min_arr = [x]\n    min_part_sums = [x]\n    part_sums = [C[0]]\n    for i in range(1, n):\n        part_sums.append(part_sums[-1] + C[i])\n    for elem in B:\n        min_arr.append(min_arr[-1] + elem)\n        min_part_sums.append(min_arr[-1] + min_part_sums[-1])\n    for i in range(n):\n        if min_part_sums[i] > part_sums[i]:\n            return 0\n    if min_part_sums[0] > C[0]:\n        return 0\n    answer = [1] * (part_sums[0] - max(0, min_part_sums[0]) + 1)\n    for k in range(1, n):\n        new_answer = [0] * (part_sums[k] - max(0, min_part_sums[k]) + 1)\n        cnt = 1\n        window = answer[-1]\n        new_answer[-1] = window\n        while cnt <= len(new_answer) - 1:\n            cnt += 1\n            if cnt <= len(answer):\n                window += answer[-cnt]\n            if C[k] + 1 < cnt:\n                window -= answer[C[k] + 1 - cnt]\n            new_answer[-cnt] = window\n        answer = new_answer.copy()\n    m = 10 ** 9 + 7\n    return sum(answer) % m\n\n\nprint(sol())","cleaned_code":"def putin():\n    return map(int, input().split())\ndef sol():\n    n = int(input())\n    C = list(putin())\n    B = list(putin())\n    q = int(input())\n    x = int(input())\n    min_arr = [x]\n    min_part_sums = [x]\n    part_sums = [C[0]]\n    for i in range(1, n):\n        part_sums.append(part_sums[-1] + C[i])\n    for elem in B:\n        min_arr.append(min_arr[-1] + elem)\n        min_part_sums.append(min_arr[-1] + min_part_sums[-1])\n    for i in range(n):\n        if min_part_sums[i] > part_sums[i]:\n            return 0\n    if min_part_sums[0] > C[0]:\n        return 0\n    answer = [1] * (part_sums[0] - max(0, min_part_sums[0]) + 1)\n    for k in range(1, n):\n        new_answer = [0] * (part_sums[k] - max(0, min_part_sums[k]) + 1)\n        cnt = 1\n        window = answer[-1]\n        new_answer[-1] = window\n        while cnt <= len(new_answer) - 1:\n            cnt += 1\n            if cnt <= len(answer):\n                window += answer[-cnt]\n            if C[k] + 1 < cnt:\n                window -= answer[C[k] + 1 - cnt]\n            new_answer[-cnt] = window\n        answer = new_answer.copy()\n    m = 10 ** 9 + 7\n    return sum(answer) % m\nprint(sol())","normalized_code":"FUNC_DEF RETURN FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR FUNC_DEF ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR LIST VAR ASSIGN VAR LIST VAR ASSIGN VAR LIST VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER VAR VAR FOR VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER VAR EXPR FUNC_CALL VAR BIN_OP VAR NUMBER VAR NUMBER FOR VAR FUNC_CALL VAR VAR IF VAR VAR VAR VAR RETURN NUMBER IF VAR NUMBER VAR NUMBER RETURN NUMBER ASSIGN VAR BIN_OP LIST NUMBER BIN_OP BIN_OP VAR NUMBER FUNC_CALL VAR NUMBER VAR NUMBER NUMBER FOR VAR FUNC_CALL VAR NUMBER VAR ASSIGN VAR BIN_OP LIST NUMBER BIN_OP BIN_OP VAR VAR FUNC_CALL VAR NUMBER VAR VAR NUMBER ASSIGN VAR NUMBER ASSIGN VAR VAR NUMBER ASSIGN VAR NUMBER VAR WHILE VAR BIN_OP FUNC_CALL VAR VAR NUMBER VAR NUMBER IF VAR FUNC_CALL VAR VAR VAR VAR VAR IF BIN_OP VAR VAR NUMBER VAR VAR VAR BIN_OP BIN_OP VAR VAR NUMBER VAR ASSIGN VAR VAR VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR BIN_OP BIN_OP NUMBER NUMBER NUMBER RETURN BIN_OP FUNC_CALL VAR VAR VAR EXPR FUNC_CALL VAR FUNC_CALL VAR","self_reflection":"```xml\n<key_elements>\n    <task>Count the number of good arrays a where F(a, b) \u2265 x for q values of x, modulo 10^9+7.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Length of array a and b, where n \u2265 2 and n \u2264 100\" unit=\"integer\"\/>\n        <variable name=\"c\" description=\"Array of length n, where 0 \u2264 c_i \u2264 100 for 1 \u2264 i \u2264 n\" unit=\"integer\"\/>\n        <variable name=\"b\" description=\"Array of length n-1, where 0 \u2264 b_i \u2264 100 for 1 \u2264 i \u2264 n-1\" unit=\"integer\"\/>\n        <variable name=\"q\" description=\"Number of queries, where q = 1\" unit=\"integer\"\/>\n        <variable name=\"x\" description=\"Array of q integers, where -10^5 \u2264 x_i \u2264 10^5 for 1 \u2264 i \u2264 q\" unit=\"integer\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n \u2264 100<\/constraint>\n        <constraint>0 \u2264 c_i \u2264 100 for 1 \u2264 i \u2264 n<\/constraint>\n        <constraint>0 \u2264 b_i \u2264 100 for 1 \u2264 i \u2264 n-1<\/constraint>\n        <constraint>q = 1<\/constraint>\n        <constraint>-10^5 \u2264 x_i \u2264 10^5 for 1 \u2264 i \u2264 q<\/constraint>\n    <\/constraints>\n    <input>\n        <line>Single integer n (2 \u2264 n \u2264 100)<\/line>\n        <line>n integers c_1, c_2, ..., c_n (0 \u2264 c_i \u2264 100)<\/line>\n        <line>n-1 integers b_1, b_2, ..., b_{n-1} (0 \u2264 b_i \u2264 100)<\/line>\n        <line>Single integer q (q=1)<\/line>\n        <line>q space separated integers x_1, x_2, ..., x_q (-10^5 \u2264 x_i \u2264 10^5)<\/line>\n    <\/input>\n    <output>\n        <description>q integers, where the i-th integer is the number of good arrays a where F(a, b) \u2265 x_i modulo 10^9+7<\/description>\n    <\/output>\n    <formulas>\n        <formula>F(a, b) = a_1<\/formula>\n    <\/formulas>\n    <logic_flow>\n        Count the number of good arrays a where the first element a_1 of the array a, after applying the process on a and b, is greater than or equal to each of the q values of x, modulo 10^9+7.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Some country is populated by wizards. They want to organize a demonstration.\nThere are n people living in the city, x of them are the wizards who will surely go to the demonstration. Other city people (n - x people) do not support the wizards and aren't going to go to the demonstration. We know that the city administration will react only to the demonstration involving at least y percent of the city people. Having considered the matter, the wizards decided to create clone puppets which can substitute the city people on the demonstration. \nSo all in all, the demonstration will involve only the wizards and their puppets. The city administration cannot tell the difference between a puppet and a person, so, as they calculate the percentage, the administration will consider the city to be consisting of only n people and not containing any clone puppets. \nHelp the wizards and find the minimum number of clones to create to that the demonstration had no less than y percent of the city people.\nInput\nThe first line contains three space-separated integers, n, x, y (1 \u2264 n, x, y \u2264 104, x \u2264 n) \u2014 the number of citizens in the city, the number of wizards and the percentage the administration needs, correspondingly.\nPlease note that y can exceed 100 percent, that is, the administration wants to see on a demonstration more people that actually live in the city ( > n).\nOutput\nPrint a single integer \u2014 the answer to the problem, the minimum number of clones to create, so that the demonstration involved no less than y percent of n (the real total city population). \nExamples\nInput\n10 1 14\nOutput\n1\nInput\n20 10 50\nOutput\n0\nInput\n1000 352 146\nOutput\n1108\nNote\nIn the first sample it is necessary that at least 14% of 10 people came to the demonstration. As the number of people should be integer, then at least two people should come. There is only one wizard living in the city and he is going to come. That isn't enough, so he needs to create one clone. \nIn the second sample 10 people should come to the demonstration. The city has 10 wizards. They will all come to the demonstration, so nobody has to create any clones.","sample_inputs":"1000 352 146\n10 1 14\n20 10 50\n","sample_outputs":"1108\n1\n0\n","cf_tags":["implementation","math"],"original_code":"num,wiz,per = map(int,input().split())\nk = 0\nwhile (k+wiz)\/num*100 < per:\n    k += 1\nprint(k)","cleaned_code":"num,wiz,per = map(int,input().split())\nk = 0\nwhile (k+wiz)\/num*100 < per:\n    k += 1\nprint(k)","normalized_code":"ASSIGN VAR VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR NUMBER WHILE BIN_OP BIN_OP BIN_OP VAR VAR VAR NUMBER VAR VAR NUMBER EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the minimum number of clones to create so that the demonstration involves no less than y percent of the city people.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The number of citizens in the city\" unit=\"people\" \/>\n        <variable name=\"x\" description=\"The number of wizards who will surely go to the demonstration\" unit=\"people\" \/>\n        <variable name=\"y\" description=\"The percentage the administration needs\" unit=\"percent\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n, x, y \u2264 10^4<\/constraint>\n        <constraint>x \u2264 n<\/constraint>\n        <constraint>y can exceed 100 percent<\/constraint>\n    <\/constraints>\n    <input>The first line contains three space-separated integers, n, x, y \u2014 the number of citizens in the city, the number of wizards, and the percentage the administration needs, correspondingly.<\/input>\n    <output>Print a single integer \u2014 the minimum number of clones to create, so that the demonstration involves no less than y percent of n (the real total city population).<\/output>\n    <formulas>\n        <formula>Minimum number of clones = ceil((y\/100) * n - x)<\/formula>\n    <\/formulas>\n    <logic_flow>\n        Calculate the minimum number of clones needed to ensure the demonstration involves at least y percent of the city people.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"You are given an equation: \nAx2 + Bx + C = 0. \nYour task is to find the number of distinct roots of the equation and print all of them in ascending order.\nInput\nThe first line contains three integer numbers A, B and C ( - 105 \u2264 A, B, C \u2264 105). Any coefficient may be equal to 0.\nOutput\nIn case of infinite root count print the only integer -1. In case of no roots print the only integer 0. In other cases print the number of root on the first line and the roots on the following lines in the ascending order. Print roots with at least 5 digits after the decimal point.\nExamples\nInput\n1 -5 6\nOutput\n2\n2.0000000000\n3.0000000000","sample_inputs":"1 -5 6\n","sample_outputs":"2\n2.000000\n3.000000\n","cf_tags":["math"],"original_code":"a, b, c = map(float, input().split())\nD = b ** 2 - (4 * a * c)\nif D < 0:\n    print(0)\nelif a == 0 and b == 0 and c != 0:\n    print(0)\nelif a == 0 and b == 0 and c == 0:\n    print(-1)\nelif a == 0:\n    x0 = c \/ -(b)\n    print(1)\n    print(x0)\nelif b == 0:\n    print(1)\n    print(0)\nelif D == 0 and (a > 0 or a < 0):\n    x = -(b) \/ (2 * a)\n    print(1)\n    print(x)\nelif D > 0 and (a > 0 or a < 0):\n    x1 = (-(b) + D ** 0.5) \/ (2 * a)\n    x2 = (-(b) - D ** 0.5) \/ (2 * a)\n    print(2)\n    g = [x1, x2]\n    for i in sorted(g):\n        print(i)\n","cleaned_code":"a, b, c = map(float, input().split())\nD = b ** 2 - (4 * a * c)\nif D < 0:\n    print(0)\nelif a == 0 and b == 0 and c != 0:\n    print(0)\nelif a == 0 and b == 0 and c == 0:\n    print(-1)\nelif a == 0:\n    x0 = c \/ -(b)\n    print(1)\n    print(x0)\nelif b == 0:\n    print(1)\n    print(0)\nelif D == 0 and (a > 0 or a < 0):\n    x = -(b) \/ (2 * a)\n    print(1)\n    print(x)\nelif D > 0 and (a > 0 or a < 0):\n    x1 = (-(b) + D ** 0.5) \/ (2 * a)\n    x2 = (-(b) - D ** 0.5) \/ (2 * a)\n    print(2)\n    g = [x1, x2]\n    for i in sorted(g):\n        print(i)\n","normalized_code":"ASSIGN VAR VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR BIN_OP BIN_OP VAR NUMBER BIN_OP BIN_OP NUMBER VAR VAR IF VAR NUMBER EXPR FUNC_CALL VAR NUMBER IF VAR NUMBER VAR NUMBER VAR NUMBER EXPR FUNC_CALL VAR NUMBER IF VAR NUMBER VAR NUMBER VAR NUMBER EXPR FUNC_CALL VAR NUMBER IF VAR NUMBER ASSIGN VAR BIN_OP VAR VAR EXPR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR VAR IF VAR NUMBER EXPR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR NUMBER IF VAR NUMBER VAR NUMBER VAR NUMBER ASSIGN VAR BIN_OP VAR BIN_OP NUMBER VAR EXPR FUNC_CALL VAR NUMBER EXPR FUNC_CALL VAR VAR IF VAR NUMBER VAR NUMBER VAR NUMBER ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER BIN_OP NUMBER VAR ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER BIN_OP NUMBER VAR EXPR FUNC_CALL VAR NUMBER ASSIGN VAR LIST VAR VAR FOR VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the number of distinct roots of the quadratic equation Ax^2 + Bx + C = 0 and print them in ascending order.<\/task>\n    <variables>\n        <variable name=\"A\" description=\"Coefficient of x^2\" unit=\"integer\" range=\"-10^5 \u2264 A \u2264 10^5\"\/>\n        <variable name=\"B\" description=\"Coefficient of x\" unit=\"integer\" range=\"-10^5 \u2264 B \u2264 10^5\"\/>\n        <variable name=\"C\" description=\"Constant term\" unit=\"integer\" range=\"-10^5 \u2264 C \u2264 10^5\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>Any coefficient (A, B, C) may be equal to 0.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains three integer numbers A, B, and C.\n    <\/input>\n    <output>\n        In case of infinite root count, print -1.\n        In case of no roots, print 0.\n        In other cases, print the number of roots on the first line and the roots on the following lines in ascending order.\n        Roots should be printed with at least 5 digits after the decimal point.\n    <\/output>\n    <formulas>\n        The discriminant \u0394 = B^2 - 4AC.\n        If \u0394 > 0, there are two distinct real roots.\n        If \u0394 = 0, there is one real root.\n        If \u0394 < 0, there are no real roots.\n    <\/formulas>\n    <logic_flow>\n        Calculate the discriminant \u0394.\n        Based on the value of \u0394, determine the number of distinct real roots.\n        If there are roots, calculate them and sort them in ascending order.\n        Print the number of roots and the roots themselves with the specified precision.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters \"-\".\nWe'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format \"dd-mm-yyyy\". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy \"0012-10-2012-10-2012\" mentions date 12-10-2012 twice (first time as \"0012-10-2012-10-2012\", second time as \"0012-10-2012-10-2012\").\nThe date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.\nA date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format \"dd-mm-yyyy\", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date \"1-1-2013\" isn't recorded in the format \"dd-mm-yyyy\", and date \"01-01-2013\" is recorded in it.\nNotice, that any year between 2013 and 2015 is not a leap year.\nInput\nThe first line contains the Prophesy: a non-empty string that only consists of digits and characters \"-\". The length of the Prophesy doesn't exceed 105 characters.\nOutput\nIn a single line print the date of the Apocalypse. It is guaranteed that such date exists and is unique.\nExamples\nInput\n777-444---21-12-2013-12-2013-12-2013---444-777\nOutput\n13-12-2013","sample_inputs":"777-444---21-12-2013-12-2013-12-2013---444-777\n","sample_outputs":"13-12-2013\n","cf_tags":["brute force","implementation","strings"],"original_code":"s=input()\nn=len(s)\nl=list(\"0987654321\")\ncnt={}\nfor i in range(n-9):\n  t=s[i:i+10]\n  if t[0] in l and t[1] in l and t[2]==\"-\" and t[3] in l and t[4] in l and t[5]==\"-\" and t[6] in l and t[7] in l and t[8] in l and t[9] in l:\n    if 2013<=int(t[6:11])<=2015  and 1<=int(t[3:5])<=12:\n      if int(t[3:5]) in [1,3,5,7,8,10,12] and 1<=int(t[0:2])<=31:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\n      elif int(t[3:5]) in [4,6,9,11] and 1<=int(t[0:2])<=30:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\n      elif int(t[3:5])==2 and 1<=int(t[0:2])<=28:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\nprint(max(cnt,key=cnt.get))","cleaned_code":"s=input()\nn=len(s)\nl=list(\"0987654321\")\ncnt={}\nfor i in range(n-9):\n  t=s[i:i+10]\n  if t[0] in l and t[1] in l and t[2]==\"-\" and t[3] in l and t[4] in l and t[5]==\"-\" and t[6] in l and t[7] in l and t[8] in l and t[9] in l:\n    if 2013<=int(t[6:11])<=2015  and 1<=int(t[3:5])<=12:\n      if int(t[3:5]) in [1,3,5,7,8,10,12] and 1<=int(t[0:2])<=31:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\n      elif int(t[3:5]) in [4,6,9,11] and 1<=int(t[0:2])<=30:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\n      elif int(t[3:5])==2 and 1<=int(t[0:2])<=28:\n        if not t in cnt:\n          cnt[t]=1\n        else:\n          cnt[t]+=1\nprint(max(cnt,key=cnt.get))","normalized_code":"ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR ASSIGN VAR FUNC_CALL VAR STRING ASSIGN VAR DICT FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR VAR VAR BIN_OP VAR NUMBER IF VAR NUMBER VAR VAR NUMBER VAR VAR NUMBER STRING VAR NUMBER VAR VAR NUMBER VAR VAR NUMBER STRING VAR NUMBER VAR VAR NUMBER VAR VAR NUMBER VAR VAR NUMBER VAR IF NUMBER FUNC_CALL VAR VAR NUMBER NUMBER NUMBER NUMBER FUNC_CALL VAR VAR NUMBER NUMBER NUMBER IF FUNC_CALL VAR VAR NUMBER NUMBER LIST NUMBER NUMBER NUMBER NUMBER NUMBER NUMBER NUMBER NUMBER FUNC_CALL VAR VAR NUMBER NUMBER NUMBER IF VAR VAR ASSIGN VAR VAR NUMBER VAR VAR NUMBER IF FUNC_CALL VAR VAR NUMBER NUMBER LIST NUMBER NUMBER NUMBER NUMBER NUMBER FUNC_CALL VAR VAR NUMBER NUMBER NUMBER IF VAR VAR ASSIGN VAR VAR NUMBER VAR VAR NUMBER IF FUNC_CALL VAR VAR NUMBER NUMBER NUMBER NUMBER FUNC_CALL VAR VAR NUMBER NUMBER NUMBER IF VAR VAR ASSIGN VAR VAR NUMBER VAR VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Identify the date in the format \"dd-mm-yyyy\" that appears most frequently in the given prophesy string, where the year is between 2013 and 2015, the month is between 1 and 12, and the day is between 1 and the last day of the month.<\/task>\n    <variables>\n        <variable name=\"prophesy\" description=\"A non-empty string consisting of digits and characters '-' representing the prophesy.\" unit=\"string\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 <= length of prophesy <= 105<\/constraint>\n        <constraint>The year in the date must be between 2013 and 2015.<\/constraint>\n        <constraint>The month in the date must be between 1 and 12.<\/constraint>\n        <constraint>The day in the date must be between 1 and the last day of the month.<\/constraint>\n    <\/constraints>\n    <input>The first line contains the prophesy: a non-empty string that only consists of digits and characters '-'.<\/input>\n    <output>In a single line print the date of the Apocalypse in the format \"dd-mm-yyyy\".<\/output>\n    <formulas>\n        <formula>None explicitly given.<\/formula>\n    <\/formulas>\n    <logic_flow>Identify all valid dates in the format \"dd-mm-yyyy\" within the prophesy string. Count the occurrences of each valid date. Determine the date with the highest count and output it.<\/logic_flow>\n<\/key_elements>\n```"}
{"description":"There are n cows playing poker at a table. For the current betting phase, each player's status is either \"ALLIN\", \"IN\", or \"FOLDED\", and does not change throughout the phase. To increase the suspense, a player whose current status is not \"FOLDED\" may show his\/her hand to the table. However, so as not to affect any betting decisions, he\/she may only do so if all other players have a status of either \"ALLIN\" or \"FOLDED\". The player's own status may be either \"ALLIN\" or \"IN\".\nFind the number of cows that can currently show their hands without affecting any betting decisions.\nInput\nThe first line contains a single integer, n (2 \u2264 n \u2264 2\u00b7105). The second line contains n characters, each either \"A\", \"I\", or \"F\". The i-th character is \"A\" if the i-th player's status is \"ALLIN\", \"I\" if the i-th player's status is \"IN\", or \"F\" if the i-th player's status is \"FOLDED\".\nOutput\nThe first line should contain a single integer denoting the number of players that can currently show their hands.\nExamples\nInput\n6\nAFFAAA\nOutput\n4\nInput\n3\nAFI\nOutput\n1\nNote\nIn the first sample, cows 1, 4, 5, and 6 can show their hands. In the second sample, only cow 3 can show her hand.","sample_inputs":"3\nAFI\n6\nAFFAAA\n","sample_outputs":"14","cf_tags":["brute force","implementation"],"original_code":"#!\/bin\/python                                                               \n# -*- coding: utf-8 -*-\n\nn = int(input())\ns = input()\nprint(int(s.count('I') == 1) if 'I' in s else s.count('A'))\n","cleaned_code":"\nn = int(input())\ns = input()\nprint(int(s.count('I') == 1) if 'I' in s else s.count('A'))\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR EXPR FUNC_CALL VAR STRING VAR FUNC_CALL VAR FUNC_CALL VAR STRING NUMBER FUNC_CALL VAR STRING","self_reflection":"```xml\n<key_elements>\n    <task>Find the number of cows that can currently show their hands without affecting any betting decisions.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The number of cows playing poker.\" unit=\"integer\" range=\"2 \u2264 n \u2264 2\u00b7105\" \/>\n        <variable name=\"status\" description=\"The status of each player, which can be 'A' (ALLIN), 'I' (IN), or 'F' (FOLDED).\" unit=\"character\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>Each player's status does not change throughout the phase.<\/constraint>\n        <constraint>A player can only show their hand if all other players have a status of either 'A' or 'F'.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains a single integer, n.\n        The second line contains n characters, each either \"A\", \"I\", or \"F\".\n    <\/input>\n    <output>\n        The first line should contain a single integer denoting the number of players that can currently show their hands.\n    <\/output>\n    <formulas>\n        <!-- No mathematical formulas are explicitly given in the problem statement. -->\n    <\/formulas>\n    <logic_flow>\n        Determine the number of players whose status is 'A' or 'F' and are not the first player in the list.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Vasily the Programmer loves romance, so this year he decided to illuminate his room with candles.\nVasily has a candles.When Vasily lights up a new candle, it first burns for an hour and then it goes out. Vasily is smart, so he can make b went out candles into a new candle. As a result, this new candle can be used like any other new candle.\nNow Vasily wonders: for how many hours can his candles light up the room if he acts optimally well? Help him find this number.\nInput\nThe single line contains two integers, a and b (1 \u2264 a \u2264 1000; 2 \u2264 b \u2264 1000).\nOutput\nPrint a single integer \u2014 the number of hours Vasily can light up the room for.\nExamples\nInput\n4 2\nOutput\n7\nInput\n6 3\nOutput\n8\nNote\nConsider the first sample. For the first four hours Vasily lights up new candles, then he uses four burned out candles to make two new ones and lights them up. When these candles go out (stop burning), Vasily can make another candle. Overall, Vasily can light up the room for 7 hours.","sample_inputs":"4 2\n6 3\n","sample_outputs":"7\n8\n","cf_tags":["implementation"],"original_code":"a, b = map(int, input().split())\nc, s = a, 0\nwhile a >= b:\n    s += a \/\/ b\n    a = (a \/\/ b) + (a % b)\nprint(s + c)\n","cleaned_code":"a, b = map(int, input().split())\nc, s = a, 0\nwhile a >= b:\n    s += a \/\/ b\n    a = (a \/\/ b) + (a % b)\nprint(s + c)\n","normalized_code":"ASSIGN VAR VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR VAR VAR NUMBER WHILE VAR VAR VAR BIN_OP VAR VAR ASSIGN VAR BIN_OP BIN_OP VAR VAR BIN_OP VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Calculate the total number of hours Vasily can light up the room with candles, given the initial number of candles and the number of candles that can be made from burned-out candles.<\/task>\n    <variables>\n        <variable name=\"a\" description=\"Initial number of candles\" unit=\"candles\"\/>\n        <variable name=\"b\" description=\"Number of burned-out candles needed to make a new candle\" unit=\"candles\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 a \u2264 1000<\/constraint>\n        <constraint>2 \u2264 b \u2264 1000<\/constraint>\n    <\/constraints>\n    <input>The single line contains two integers, a and b (1 \u2264 a \u2264 1000; 2 \u2264 b \u2264 1000).<\/input>\n    <output>Print a single integer \u2014 the number of hours Vasily can light up the room for.<\/output>\n    <formulas\/>\n    <logic_flow>Calculate the total number of hours Vasily can light up the room by considering the initial candles and the process of making new candles from burned-out ones.<\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Petya studies positional notations. He has already learned to add and subtract numbers in the systems of notations with different radices and has moved on to a more complicated action \u2014 multiplication. To multiply large numbers one has to learn the multiplication table. Unfortunately, in the second grade students learn only the multiplication table of decimals (and some students even learn it in the first grade). Help Petya make a multiplication table for numbers in the system of notations with the radix k.\nInput\nThe first line contains a single integer k (2 \u2264 k \u2264 10) \u2014 the radix of the system.\nOutput\nOutput the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. The element on the crossing of the i-th row and the j-th column is equal to the product of i and j in the system of notations with the radix k. Each line may have any number of spaces between the numbers (the extra spaces in the samples are put for clarity).\nExamples\nInput\n10\nOutput\n1  2  3  4  5  6  7  8  9\n2  4  6  8 10 12 14 16 18\n3  6  9 12 15 18 21 24 27\n4  8 12 16 20 24 28 32 36\n5 10 15 20 25 30 35 40 45\n6 12 18 24 30 36 42 48 54\n7 14 21 28 35 42 49 56 63\n8 16 24 32 40 48 56 64 72\n9 18 27 36 45 54 63 72 81\nInput\n3\nOutput\n1  2\n2 11","sample_inputs":"10\n3\n","sample_outputs":"1  2  3  4  5  6  7  8  9 \n2  4  6  8 10 12 14 16 18 \n3  6  9 12 15 18 21 24 27 \n4  8 12 16 20 24 28 32 36 \n5 10 15 20 25 30 35 40 45 \n6 12 18 24 30 36 42 48 54 \n7 14 21 28 35 42 49 56 63 \n8 16 24 32 40 48 56 64 72 \n9 18 27 36 45 54 63 72 81 \n1  2 \n2 11 \n","cf_tags":["implementation"],"original_code":"k=int(input())\nfor i in range(1,k):\n    z,a=i,[]\n    for j in range(k-1):\n        p,s=z,\"\"\n        while p:\n            s=str(p%k)+s\n            p\/\/=k\n        z+=i\n        a.append(s)\n    print(*a)\n\n    \n","cleaned_code":"k=int(input())\nfor i in range(1,k):\n    z,a=i,[]\n    for j in range(k-1):\n        p,s=z,\"\"\n        while p:\n            s=str(p%k)+s\n            p\/\/=k\n        z+=i\n        a.append(s)\n    print(*a)\n","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR FOR VAR FUNC_CALL VAR NUMBER VAR ASSIGN VAR VAR VAR LIST FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR VAR VAR STRING WHILE VAR ASSIGN VAR BIN_OP FUNC_CALL VAR BIN_OP VAR VAR VAR VAR VAR VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Generate a multiplication table for numbers in a system of notations with a given radix k.<\/task>\n    <variables>\n        <variable name=\"k\" description=\"The radix of the system\" unit=\"integer\" range=\"2 \u2264 k \u2264 10\"\/><\/variables>\n    <constraints>\n        <constraint>2 \u2264 k \u2264 10<\/constraint>\n    <\/constraints>\n    <input>The first line contains a single integer k (2 \u2264 k \u2264 10) \u2014 the radix of the system.<\/input>\n    <output>Output the multiplication table for the system of notations with the radix k. The table must contain k - 1 rows and k - 1 columns. Each line may have any number of spaces between the numbers.<\/output>\n    <formulas\/>\n    <logic_flow>Generate a multiplication table where each element at the crossing of the i-th row and the j-th column is the product of i and j in the system of notations with the radix k.<\/logic_flow>\n<\/key_elements>\n```"}
{"description":"To celebrate the opening of the Winter Computer School the organizers decided to buy in n liters of cola. However, an unexpected difficulty occurred in the shop: it turned out that cola is sold in bottles 0.5, 1 and 2 liters in volume. At that, there are exactly a bottles 0.5 in volume, b one-liter bottles and c of two-liter ones. The organizers have enough money to buy any amount of cola. What did cause the heated arguments was how many bottles of every kind to buy, as this question is pivotal for the distribution of cola among the participants (and organizers as well).\nThus, while the organizers are having the argument, discussing different variants of buying cola, the Winter School can't start. Your task is to count the number of all the possible ways to buy exactly n liters of cola and persuade the organizers that this number is too large, and if they keep on arguing, then the Winter Computer School will have to be organized in summer.\nAll the bottles of cola are considered indistinguishable, i.e. two variants of buying are different from each other only if they differ in the number of bottles of at least one kind.\nInput\nThe first line contains four integers \u2014 n, a, b, c (1 \u2264 n \u2264 10000, 0 \u2264 a, b, c \u2264 5000).\nOutput\nPrint the unique number \u2014 the solution to the problem. If it is impossible to buy exactly n liters of cola, print 0. \nExamples\nInput\n10 5 5 5\nOutput\n9\nInput\n3 0 0 2\nOutput\n0","sample_inputs":"10 5 5 5\n3 0 0 2\n","sample_outputs":"9\n0\n","cf_tags":["implementation"],"original_code":"def nik(rudy,x,y,z,cot):\n    \n    for i in range(z+1):\n        for j in range(y+1):\n            t = rudy - i*2 -j\n            if t>=0 and x*0.5 >= t:\n                cot+=1\n    return cot\nrudy, x, y, z = list(map(int,input().split()))\ncot = 0\nprint(nik(rudy,x,y,z,cot))\n\n","cleaned_code":"def nik(rudy,x,y,z,cot):\n    for i in range(z+1):\n        for j in range(y+1):\n            t = rudy - i*2 -j\n            if t>=0 and x*0.5 >= t:\n                cot+=1\n    return cot\nrudy, x, y, z = list(map(int,input().split()))\ncot = 0\nprint(nik(rudy,x,y,z,cot))\n","normalized_code":"FUNC_DEF FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER FOR VAR FUNC_CALL VAR BIN_OP VAR NUMBER ASSIGN VAR BIN_OP BIN_OP VAR BIN_OP VAR NUMBER VAR IF VAR NUMBER BIN_OP VAR NUMBER VAR VAR NUMBER RETURN VAR ASSIGN VAR VAR VAR VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR NUMBER EXPR FUNC_CALL VAR FUNC_CALL VAR VAR VAR VAR VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Count the number of ways to buy exactly n liters of cola using bottles of 0.5, 1, and 2 liters in volume, given the constraints on the number of each type of bottle available.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"The total amount of cola in liters to be bought\" unit=\"liters\" \/>\n        <variable name=\"a\" description=\"The number of 0.5-liter bottles available\" unit=\"bottles\" \/>\n        <variable name=\"b\" description=\"The number of 1-liter bottles available\" unit=\"bottles\" \/>\n        <variable name=\"c\" description=\"The number of 2-liter bottles available\" unit=\"bottles\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>1 \u2264 n \u2264 10000<\/constraint>\n        <constraint>0 \u2264 a, b, c \u2264 5000<\/constraint>\n    <\/constraints>\n    <input>The first line contains four integers \u2014 n, a, b, c.<\/input>\n    <output>Print the unique number \u2014 the solution to the problem. If it is impossible to buy exactly n liters of cola, print 0.<\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>Count the number of ways to buy exactly n liters of cola using the available bottles of 0.5, 1, and 2 liters in volume.<\/logic_flow>\n<\/key_elements>\n```"}
{"description":"A and B are preparing themselves for programming contests.\nB loves to debug his code. But before he runs the solution and starts debugging, he has to first compile the code.\nInitially, the compiler displayed n compilation errors, each of them is represented as a positive integer. After some effort, B managed to fix some mistake and then another one mistake.\nHowever, despite the fact that B is sure that he corrected the two errors, he can not understand exactly what compilation errors disappeared \u2014 the compiler of the language which B uses shows errors in the new order every time! B is sure that unlike many other programming languages, compilation errors for his programming language do not depend on each other, that is, if you correct one error, the set of other error does not change.\nCan you help B find out exactly what two errors he corrected?\nInput\nThe first line of the input contains integer n (3 \u2264 n \u2264 105) \u2014 the initial number of compilation errors.\nThe second line contains n space-separated integers a1, a2, ..., an (1 \u2264 ai \u2264 109) \u2014 the errors the compiler displayed for the first time. \nThe third line contains n - 1 space-separated integers b1, b2, ..., bn - 1 \u2014 the errors displayed at the second compilation. It is guaranteed that the sequence in the third line contains all numbers of the second string except for exactly one. \nThe fourth line contains n - 2 space-separated integers \u04411, \u04412, ..., \u0441n - 2 \u2014 the errors displayed at the third compilation. It is guaranteed that the sequence in the fourth line contains all numbers of the third line except for exactly one. \nOutput\nPrint two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively. \nExamples\nInput\n5\n1 5 8 123 7\n123 7 5 1\n5 1 7\nOutput\n8\n123\nInput\n6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\nOutput\n1\n3\nNote\nIn the first test sample B first corrects the error number 8, then the error number 123.\nIn the second test sample B first corrects the error number 1, then the error number 3. Note that if there are multiple errors with the same number, B can correct only one of them in one step. ","sample_inputs":"6\n1 4 3 3 5 7\n3 7 5 4 3\n4 3 7 5\n5\n1 5 8 123 7\n123 7 5 1\n5 1 7\n","sample_outputs":"1\n3\n8\n123\n","cf_tags":["data structures","implementation","sortings"],"original_code":"n = int(input())\na_sum = sum(map(int, input().split()))\nb_sum = sum(map(int, input().split()))\nc_sum = sum(map(int, input().split()))\nprint(a_sum - b_sum)  \nprint(b_sum - c_sum)  ","cleaned_code":"n = int(input())\na_sum = sum(map(int, input().split()))\nb_sum = sum(map(int, input().split()))\nc_sum = sum(map(int, input().split()))\nprint(a_sum - b_sum)  \nprint(b_sum - c_sum)  ","normalized_code":"ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR EXPR FUNC_CALL VAR BIN_OP VAR VAR EXPR FUNC_CALL VAR BIN_OP VAR VAR","self_reflection":"```xml\n<key_elements>\n    <task>Find the two compilation errors that disappeared after B made the first and the second correction.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Initial number of compilation errors\" unit=\"integer\" \/>\n        <variable name=\"a\" description=\"Initial list of compilation errors\" unit=\"list of integers\" \/>\n        <variable name=\"b\" description=\"List of compilation errors after the first correction\" unit=\"list of integers\" \/>\n        <variable name=\"c\" description=\"List of compilation errors after the second correction\" unit=\"list of integers\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>3 \u2264 n \u2264 105<\/constraint>\n        <constraint>1 \u2264 ai \u2264 109<\/constraint>\n        <constraint>The sequence in b contains all numbers of a except for exactly one.<\/constraint>\n        <constraint>The sequence in c contains all numbers of b except for exactly one.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains integer n.\n        The second line contains n space-separated integers a1, a2, ..., an.\n        The third line contains n - 1 space-separated integers b1, b2, ..., bn - 1.\n        The fourth line contains n - 2 space-separated integers c1, c2, ..., cn - 2.\n    <\/input>\n    <output>\n        Print two numbers on a single line: the numbers of the compilation errors that disappeared after B made the first and the second correction, respectively.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement -->\n    <\/formulas>\n    <logic_flow>\n        Identify the error that disappeared after the first correction by comparing the lists a and b.\n        Identify the error that disappeared after the second correction by comparing the lists b and c.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Little Susie listens to fairy tales before bed every day. Today's fairy tale was about wood cutters and the little girl immediately started imagining the choppers cutting wood. She imagined the situation that is described below.\nThere are n trees located along the road at points with coordinates x1, x2, ..., xn. Each tree has its height hi. Woodcutters can cut down a tree and fell it to the left or to the right. After that it occupies one of the segments [xi - hi, xi] or [xi;xi + hi]. The tree that is not cut down occupies a single point with coordinate xi. Woodcutters can fell a tree if the segment to be occupied by the fallen tree doesn't contain any occupied point. The woodcutters want to process as many trees as possible, so Susie wonders, what is the maximum number of trees to fell. \nInput\nThe first line contains integer n (1 \u2264 n \u2264 105) \u2014 the number of trees.\nNext n lines contain pairs of integers xi, hi (1 \u2264 xi, hi \u2264 109) \u2014 the coordinate and the height of the \u0456-th tree.\nThe pairs are given in the order of ascending xi. No two trees are located at the point with the same coordinate.\nOutput\nPrint a single number \u2014 the maximum number of trees that you can cut down by the given rules.\nExamples\nInput\n5\n1 2\n2 1\n5 10\n10 9\n19 1\nOutput\n3\nInput\n5\n1 2\n2 1\n5 10\n10 9\n20 1\nOutput\n4\nNote\nIn the first sample you can fell the trees like that: \n  * fell the 1-st tree to the left \u2014 now it occupies segment [ - 1;1]\n  * fell the 2-nd tree to the right \u2014 now it occupies segment [2;3]\n  * leave the 3-rd tree \u2014 it occupies point 5\n  * leave the 4-th tree \u2014 it occupies point 10\n  * fell the 5-th tree to the right \u2014 now it occupies segment [19;20]\nIn the second sample you can also fell 4-th tree to the right, after that it will occupy segment [10;19].","sample_inputs":"5\n1 2\n2 1\n5 10\n10 9\n20 1\n5\n1 2\n2 1\n5 10\n10 9\n19 1\n","sample_outputs":"4\n3\n","cf_tags":["dp","greedy"],"original_code":"ll=lambda:map(int,input().split())\nt=lambda:int(input())\nss=lambda:input()\n#from math import log10 ,log2,ceil,factorial as f,gcd\n#from itertools import combinations_with_replacement as cs \n#from functools import reduce\n#from bisect import bisect_right as br\n#from collections import Counter\n\nn=t()\nx,h=[],[]\nfor _ in range(n):\n    a,b=ll()\n    x.append(a)\n    h.append(b)\nif n>=2:\n    c=2\n    tx=x[0]\n    for i in range(1,n-1):\n        if x[i]-tx>h[i]:\n            tx=x[i]\n            c+=1\n        elif x[i+1]-x[i]>h[i]:\n            tx=x[i]+h[i]\n            c+=1\n        else:\n            tx=x[i]\n    print(c)\nelse:\n    print(1)","cleaned_code":"ll=lambda:map(int,input().split())\nt=lambda:int(input())\nss=lambda:input()\nn=t()\nx,h=[],[]\nfor _ in range(n):\n    a,b=ll()\n    x.append(a)\n    h.append(b)\nif n>=2:\n    c=2\n    tx=x[0]\n    for i in range(1,n-1):\n        if x[i]-tx>h[i]:\n            tx=x[i]\n            c+=1\n        elif x[i+1]-x[i]>h[i]:\n            tx=x[i]+h[i]\n            c+=1\n        else:\n            tx=x[i]\n    print(c)\nelse:\n    print(1)","normalized_code":"ASSIGN VAR FUNC_CALL VAR VAR FUNC_CALL FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR ASSIGN VAR VAR LIST LIST FOR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR FUNC_CALL VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR VAR IF VAR NUMBER ASSIGN VAR NUMBER ASSIGN VAR VAR NUMBER FOR VAR FUNC_CALL VAR NUMBER BIN_OP VAR NUMBER IF BIN_OP VAR VAR VAR VAR VAR ASSIGN VAR VAR VAR VAR NUMBER IF BIN_OP VAR BIN_OP VAR NUMBER VAR VAR VAR VAR ASSIGN VAR BIN_OP VAR VAR VAR VAR VAR NUMBER ASSIGN VAR VAR VAR EXPR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR NUMBER","self_reflection":"```xml\n<key_elements>\n    <task>Find the maximum number of trees that can be cut down such that the segment occupied by each fallen tree does not contain any occupied point.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of trees\" unit=\"integer\" range=\"1 \u2264 n \u2264 105\" \/>\n        <variable name=\"xi\" description=\"Coordinate of the i-th tree\" unit=\"integer\" range=\"1 \u2264 xi \u2264 109\" \/>\n        <variable name=\"hi\" description=\"Height of the i-th tree\" unit=\"integer\" range=\"1 \u2264 hi \u2264 109\" \/>\n    <\/variables>\n    <constraints>\n        <constraint>xi, hi are given in ascending order of xi.<\/constraint>\n        <constraint>No two trees are located at the same coordinate.<\/constraint>\n    <\/constraints>\n    <input>\n        The first line contains an integer n.\n        The next n lines contain pairs of integers xi, hi.\n    <\/input>\n    <output>\n        Print a single integer representing the maximum number of trees that can be cut down.\n    <\/output>\n    <formulas>\n        <!-- No formulas are explicitly given in the problem statement. -->\n    <\/formulas>\n    <logic_flow>\n        Determine the maximum number of trees that can be cut down such that the segment occupied by each fallen tree does not contain any occupied point.\n    <\/logic_flow>\n<\/key_elements>\n```"}
{"description":"Every day Ruslan tried to count sheep to fall asleep, but this didn't help. Now he has found a more interesting thing to do. First, he thinks of some set of circles on a plane, and then tries to choose a beautiful set of points, such that there is at least one point from the set inside or on the border of each of the imagined circles.\nYesterday Ruslan tried to solve this problem for the case when the set of points is considered beautiful if it is given as (xt = f(t), yt = g(t)), where argument t takes all integer values from 0 to 50. Moreover, f(t) and g(t) should be correct functions.\nAssume that w(t) and h(t) are some correct functions, and c is an integer ranging from 0 to 50. The function s(t) is correct if it's obtained by one of the following rules: \n  1. s(t) = abs(w(t)), where abs(x) means taking the absolute value of a number x, i.e. |x|;\n  2. s(t) = (w(t) + h(t));\n  3. s(t) = (w(t) - h(t));\n  4. s(t) = (w(t) * h(t)), where  *  means multiplication, i.e. (w(t)\u00b7h(t));\n  5. s(t) = c;\n  6. s(t) = t;\nYesterday Ruslan thought on and on, but he could not cope with the task. Now he asks you to write a program that computes the appropriate f(t) and g(t) for any set of at most 50 circles.\nIn each of the functions f(t) and g(t) you are allowed to use no more than 50 multiplications. The length of any function should not exceed 100\u00b7n characters. The function should not contain spaces.\nRuslan can't keep big numbers in his memory, so you should choose f(t) and g(t), such that for all integer t from 0 to 50 value of f(t) and g(t) and all the intermediate calculations won't exceed 109 by their absolute value.\nInput\nThe first line of the input contains number n (1 \u2264 n \u2264 50) \u2014 the number of circles Ruslan thinks of. Next follow n lines, each of them containing three integers xi, yi and ri (0 \u2264 xi, yi \u2264 50, 2 \u2264 ri \u2264 50) \u2014 the coordinates of the center and the raduis of the i-th circle.\nOutput\nIn the first line print a correct function f(t). In the second line print a correct function g(t). The set of the points (xt = f(t), yt = g(t)) (0 \u2264 t \u2264 50) must satisfy the condition, that there is at least one point inside or on the border of each of the circles, Ruslan thinks of at the beginning.\nExamples\nInput\n3\n0 10 4\n10 0 4\n20 10 4\nOutput\nt \nabs((t-10))\nNote\nCorrect functions:\n  1. 10\n  2. (1+2)\n  3. ((t-3)+(t*4))\n  4. abs((t-10))\n  5. (abs((((23-t)*(t*t))+((45+12)*(t*t))))*((5*t)+((12*t)-13)))\n  6. abs((t-(abs((t*31))+14))))\nIncorrect functions:\n  1. 3+5+7 (not enough brackets, it should be ((3+5)+7) or (3+(5+7))) \n  2. abs(t-3) (not enough brackets, it should be abs((t-3))\n  3. 2+(2-3 (one bracket too many)\n  4. 1(t+5) (no arithmetic operation between 1 and the bracket)\n  5. 5000*5000 (the number exceeds the maximum)\n<image> The picture shows one of the possible solutions","sample_inputs":"3\n0 10 4\n10 0 4\n20 10 4\n","sample_outputs":"(((0*((1-abs((t-0)))+abs((abs((t-0))-1))))+(5*((1-abs((t-1)))+abs((abs((t-1))-1)))))+(10*((1-abs((t-2)))+abs((abs((t-2))-1)))))\n(((5*((1-abs((t-0)))+abs((abs((t-0))-1))))+(0*((1-abs((t-1)))+abs((abs((t-1))-1)))))+(5*((1-abs((t-2)))+abs((abs((t-2))-1)))))\n","cf_tags":["constructive algorithms","math"],"original_code":"def f(x):\n\n        if x == n:\n\n                return \"0\"\n\n        if x == 0:\n\n                return \"(\" + str(X[0]) + \"+\" + f(1) + \")\"\n\n        ss = \"(abs((t-\" + str(x-1) + \"))-abs((t-\" + str(x)  + \")))\"\n\n        tmp = (X[x] - X[x - 1]) \/\/ 2\n\n        re = (X[x] - X[x - 1]) -  2 * tmp\n\n        X[x] -= re\n\n        if tmp < 0:\n\n                tmp = \"(0\" +str(tmp)+\")\"\n\n        ss = \"((\" + str(tmp) + \"*\" + ss + \")\" + \"+\" + str(tmp) + \")\"\n\n        return \"(\" + ss + \"+\" + f(x + 1) + \")\"\n\n\n\nn = int(input())\n\n#c = [(int(_) for _ in input().split()) for i in range(n)]\n\nc = [[int(x) for x in input().split()] for i in range(n)]\n\n#print(n, c)\n\nX = [c[i][0] for i in range(n)]\n\nY = [c[i][1] for i in range(n)]\n\n#print(X)\n\n#print(Y)\n\nprint(f(0))\n\n#print(X)\n\nX = Y\n\nprint(f(0))\n\n\n\n\n\n# Made By Mostafa_Khaled","cleaned_code":"def f(x):\n        if x == n:\n                return \"0\"\n        if x == 0:\n                return \"(\" + str(X[0]) + \"+\" + f(1) + \")\"\n        ss = \"(abs((t-\" + str(x-1) + \"))-abs((t-\" + str(x)  + \")))\"\n        tmp = (X[x] - X[x - 1]) \/\/ 2\n        re = (X[x] - X[x - 1]) -  2 * tmp\n        X[x] -= re\n        if tmp < 0:\n                tmp = \"(0\" +str(tmp)+\")\"\n        ss = \"((\" + str(tmp) + \"*\" + ss + \")\" + \"+\" + str(tmp) + \")\"\n        return \"(\" + ss + \"+\" + f(x + 1) + \")\"\nn = int(input())\nc = [[int(x) for x in input().split()] for i in range(n)]\nX = [c[i][0] for i in range(n)]\nY = [c[i][1] for i in range(n)]\nprint(f(0))\nX = Y\nprint(f(0))\n","normalized_code":"FUNC_DEF IF VAR VAR RETURN STRING IF VAR NUMBER RETURN BIN_OP BIN_OP BIN_OP BIN_OP STRING FUNC_CALL VAR VAR NUMBER STRING FUNC_CALL VAR NUMBER STRING ASSIGN VAR BIN_OP BIN_OP BIN_OP BIN_OP STRING FUNC_CALL VAR BIN_OP VAR NUMBER STRING FUNC_CALL VAR VAR STRING ASSIGN VAR BIN_OP BIN_OP VAR VAR VAR BIN_OP VAR NUMBER NUMBER ASSIGN VAR BIN_OP BIN_OP VAR VAR VAR BIN_OP VAR NUMBER BIN_OP NUMBER VAR VAR VAR VAR IF VAR NUMBER ASSIGN VAR BIN_OP BIN_OP STRING FUNC_CALL VAR VAR STRING ASSIGN VAR BIN_OP BIN_OP BIN_OP BIN_OP BIN_OP BIN_OP BIN_OP STRING FUNC_CALL VAR VAR STRING VAR STRING STRING FUNC_CALL VAR VAR STRING RETURN BIN_OP BIN_OP BIN_OP BIN_OP STRING VAR STRING FUNC_CALL VAR BIN_OP VAR NUMBER STRING ASSIGN VAR FUNC_CALL VAR FUNC_CALL VAR ASSIGN VAR FUNC_CALL VAR VAR VAR FUNC_CALL FUNC_CALL VAR VAR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR NUMBER VAR FUNC_CALL VAR VAR ASSIGN VAR VAR VAR NUMBER VAR FUNC_CALL VAR VAR EXPR FUNC_CALL VAR FUNC_CALL VAR NUMBER ASSIGN VAR VAR EXPR FUNC_CALL VAR FUNC_CALL VAR NUMBER","self_reflection":"```xml\n<key_elements>\n    <task>Compute the appropriate f(t) and g(t) for a set of circles such that there is at least one point (xt = f(t), yt = g(t)) inside or on the border of each circle.<\/task>\n    <variables>\n        <variable name=\"n\" description=\"Number of circles\" unit=\"integer\" range=\"1 \u2264 n \u2264 50\"\/>\n        <variable name=\"xi, yi, ri\" description=\"Coordinates of the center and radius of the i-th circle\" unit=\"integer\" range=\"0 \u2264 xi, yi \u2264 50, 2 \u2264 ri \u2264 50\"\/>\n        <variable name=\"t\" description=\"Argument for the functions f(t) and g(t)\" unit=\"integer\" range=\"0 \u2264 t \u2264 50\"\/>\n        <variable name=\"f(t)\" description=\"Function for x-coordinate\" unit=\"integer\" length=\"\u2264 100\u00b7n characters\" max_value=\"10^9\"\/>\n        <variable name=\"g(t)\" description=\"Function for y-coordinate\" unit=\"integer\" length=\"\u2264 100\u00b7n characters\" max_value=\"10^9\"\/>\n    <\/variables>\n    <constraints>\n        <constraint>Each function f(t) and g(t) can use no more than 50 multiplications.<\/constraint>\n        <constraint>The length of any function should not exceed 100\u00b7n characters.<\/constraint>\n        <constraint>The function should not contain spaces.<\/constraint>\n        <constraint>The value of f(t) and g(t) and all intermediate calculations should not exceed 10^9 by their absolute value.<\/constraint>\n    <\/constraints>\n    <input>\n        <line>Number of circles (n)<\/line>\n        <line>Coordinates and radius of each circle (xi, yi, ri)<\/line>\n    <\/input>\n    <output>\n        <line>Function f(t)<\/line>\n        <line>Function g(t)<\/line>\n    <\/output>\n    <formulas>\n        <formula>s(t) = abs(w(t))<\/formula>\n        <formula>s(t) = (w(t) + h(t))<\/formula>\n        <formula>s(t) = (w(t) - h(t))<\/formula>\n        <formula>s(t) = (w(t) * h(t))<\/formula>\n        <formula>s(t) = c<\/formula>\n        <formula>s(t) = t<\/formula>\n    <\/formulas>\n    <logic_flow>\n        Compute functions f(t) and g(t) such that for each circle, there is at least one point (xt = f(t), yt = g(t)) inside or on the border of the circle.\n    <\/logic_flow>\n<\/key_elements>\n```"}
